<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BackUps by The Refresh</title>
  <link rel="icon" type="image/png" href="RF5.png">
  <style>
    :root {
      --gap: 1rem;
      --pad: .5rem;
      --primary: #2196F3;
      --primary-dark: #1976D2;
      --secondary: #21CBF3;
      --text: #e4e8ff;
      --text-light: #9aa3d9;
      --bg: #050810;
      --card-bg: rgba(7, 12, 30, 0.92);
      --border: rgba(120, 141, 255, 0.35);
      --success: #4CAF50;
      --error: #f44336;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #000;
      color: var(--text);
      line-height: 1.6;
    }

    /* --- WALLET GATE OVERLAY --- */
    #gateOverlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 10;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      background: radial-gradient(circle at top left, #202738 0, #050810 55%, #020308 100%);
      color: #e4e8ff;
    }

    header {
      position: relative;
      background: transparent;
      color: white;
      text-align: center;
      padding: 2rem var(--pad) 1.5rem;
      box-shadow: none;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    #description {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 1.5rem;
    }

    #instructions {
      font-size: 1rem;
      margin: 1rem 0;
      color: #a9b5ff;
    }

    #walletStatus {
      background: rgba(9, 16, 40, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(106, 255, 183, 0.4);
      color: #a7ffcb;
      padding: 0.5rem 1.5rem;
      display: inline-block;
      margin-top: 1rem;
      font-weight: 500;
      backdrop-filter: blur(5px);
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 0 var(--pad);
    }

    .card {
      background: rgba(5, 10, 24, 0.9);
      border-radius: 18px;
      border: 1px solid rgba(120, 141, 255, 0.25);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      color: #e4e8ff;
      backdrop-filter: blur(10px);
      padding: 2rem;
      margin: 2rem auto;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    button:disabled,
.loc-btn-primary:disabled,
.loc-btn-secondary:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

    

    #connectBtn {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #connectBtn:hover {
      background: linear-gradient(135deg, #ff4b80, #ffd46b);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.7);
    }

    #connectBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    #payAccessBtn {
      margin-top: 0.75rem;
      background: linear-gradient(135deg, #21cbf3, #7cffb3);
      color: #050814;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #payAccessBtn:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
    }

    select, input {
      padding: 0.8rem;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 1rem;
      width: 100%;
      background: rgba(3, 7, 20, 0.9);
      border-color: rgba(96, 125, 255, 0.6);
      color: #e4e8ff;
    }

    .hidden { display: none !important; }

    .access-message {
      margin-top: 1rem;
      font-size: 1rem;
      color: #b7c3ff;
      white-space: pre-line;
    }

    .access-message strong { color: var(--success); }
    .access-message.error { color: #ff8b94; }

    .access-message a {
      color: #ffc857;
      text-decoration: underline;
    }

    header .container {
      max-width: 860px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .brand-logo {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      width: 52px;
      height: auto;
      padding: 0.25rem;
      background: rgba(5, 8, 16, 0.9);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
    }

    header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.04em;
    }
    .backups-logo-text {
  display: inline-block;
  background: linear-gradient(135deg, #ff9a3c, #ffd869);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-weight: 800;
  text-shadow: 0 0 18px rgba(255, 200, 120, 0.55);
}


    /* Gated area layout */
    .loc-container {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      max-width: 720px;
      margin: 0 auto;
      padding: 1.5rem 1.75rem;
    }

    .loc-header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .loc-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
    }

    .loc-title-accent {
      opacity: 0.8;
      font-size: 0.95em;
    }

    .loc-subtitle {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .loc-status-block {
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(6px);
    }

    .loc-status {
      margin: 0;
      font-size: 0.95rem;
    }

    .loc-status-ok {
      font-weight: 500;
    }

.loc-main {
  display: grid;
  grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
  gap: 1.25rem;
  width: 100%;
  margin-bottom: 1.75rem; /* extra space above thumbnails / next section */
  align-items: stretch;
}

/* Baseline for mobile: let cards grow naturally in a single column */
.loc-main .loc-card {
  min-height: 260px;
}

/* Desktop: lock both cards to the same height and keep them from shifting */
@media (min-width: 801px) {
  .loc-main {
    grid-auto-rows: 1fr;
  }

  .loc-main .loc-column {
    height: 100%;
  }

  .loc-main .loc-card {
    height: 420px;      /* tweak this number to taste (390‚Äì450px range works well) */
    min-height: 420px;
    overflow: hidden;   /* card itself never grows; inner areas will scroll if needed */
    display: flex;
    flex-direction: column;
  }

  /* Any expanding blocks inside the cards get the scroll, not the card height */
  .loc-main .loc-card .loc-results-details {
    flex: 1 1 auto;
    min-height: 0;
    overflow: auto;
  }
}



    .loc-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .loc-card {
      background: rgba(5, 12, 28, 0.95);
      border-radius: 0.9rem;
      border: 1px solid rgba(120, 141, 255, 0.2);
      padding: 1rem 1.1rem;
      font-size: 0.9rem;
    }

    .loc-card h3 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1rem;
    }

    .loc-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 0.75rem;
      font-size: 0.85rem;
    }

    .loc-field span {
      opacity: 0.85;
    }

    .loc-field input {
      border-radius: 0.6rem;
      padding: 0.55rem 0.7rem;
    }

        /* Fixed visual block for the summary so the card doesn't jump */
    #backupsResultsSummary {
      min-height: 3.5em;      /* enough for 2‚Äì3 lines of text */
      display: flex;
      align-items: flex-start;
    }

    #backupsResultsSummary > span {
      display: block;
    }


    .loc-btn-primary,
    .loc-btn-secondary {
      border-radius: 999px;
      padding: 0.55rem 1rem;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    .loc-btn-primary {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 20px rgba(0,0,0,0.7);
      margin-top: 0.25rem;
    }

    .loc-btn-primary:hover {
      transform: translateY(-1px) scale(1.01);
    }

    .loc-btn-secondary {
      background: rgba(10, 18, 46, 0.9);
      color: #e4e8ff;
      border: 1px solid rgba(120, 141, 255, 0.6);
    }

    .loc-hint {
      font-size: 0.75rem;
      opacity: 0.75;
    }

.loc-tx-status {
  margin-top: 0.5rem;
  font-size: 0.8rem;
  opacity: 0.9;
  word-break: normal;        /* don‚Äôt break inside words */
  overflow-wrap: break-word; /* still wrap very long hashes/URLs when needed */
}

    
.loc-status-stack {
  margin-top: 0.75rem;
  padding-top: 0.5rem;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  min-height: 7.5em; /* reserves space for multi-line fee/scan/quote messages */
}

/* Make the bottom tracking log a bit more compact & readable */
.loc-status-stack .loc-tx-status {
  margin-top: 0;          /* handled by gap above */
  font-size: 0.75rem;     /* slightly smaller so long lines feel tidy */
  line-height: 1.4;
  white-space: pre-line;  /* respects your \n in JS messages */
}


.access-steps {
  margin-top: 0.75rem;
  padding: 0.75rem 0;
  border-top: 1px solid rgba(255, 255, 255, 0.06);
}

.gate-subtitle {
  margin: 0 0 0.35rem 0;
  font-size: 0.9rem;
  font-weight: 600;
  opacity: 0.9;
}

.gate-list {
  margin: 0;
  padding-left: 1.25rem;
  font-size: 0.8rem;
  opacity: 0.9;
}

.gate-list li {
  margin-bottom: 0.25rem;
}

.loc-substeps {
  margin-top: 0.35rem;
}

.loc-substeps ul {
  margin: 0.25rem 0 0;
  padding-left: 1.1rem;
  font-size: 0.8rem;
  opacity: 0.9;
}

.loc-substeps li {
  margin-bottom: 0.2rem;
}

.loc-legal {
  margin-top: 0.75rem;
  font-size: 0.7rem;
  opacity: 0.75;
}

.loc-legal-text {
  margin: 0;
  line-height: 1.5;
}

.backups-mode-toggle {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
  background: rgba(10, 18, 46, 0.75);
  border-radius: 999px;
  padding: 0.2rem 0.5rem;
}

/* Wallet assets section */
#walletAssetsSection {
  margin-top: 1rem;
  border-radius: 0.75rem;
  border: 1px solid rgba(255, 255, 255, 0.08);
  background: rgba(5, 10, 24, 0.9);
  padding: 0.75rem 0.9rem 1rem;
}

/* Filter wrapper */
.wallet-filter-details {
  margin: 0.4rem 0 0.6rem;
  border-radius: 0.6rem;
  border: 1px solid rgba(255, 255, 255, 0.06);
  background: rgba(5, 10, 24, 0.85);
  padding: 0.4rem 0.6rem 0.55rem;
}

.wallet-filter-summary {
  list-style: none;
  cursor: pointer;
  font-size: 0.8rem;
  display: flex;
  align-items: center;
  gap: 0.35rem;
  color: #e4e8ff;
}

.wallet-filter-summary::-webkit-details-marker {
  display: none;
}

.wallet-filter-summary::before {
  content: '‚ñ∏';
  font-size: 0.75rem;
  opacity: 0.8;
  transition: transform 0.15s ease;
}

.wallet-filter-details[open] .wallet-filter-summary::before {
  transform: rotate(90deg);
}

.wallet-select-all {
  margin-left: auto;                 /* push it to the right side */
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.75rem;
  opacity: 0.9;
}

.wallet-select-all input {
  cursor: pointer;
}


.wallet-filters-container {
  margin-top: 0.35rem;
  max-height: 190px;
  overflow: auto;
}

.wallet-filters-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6rem;
}

.wallet-filter-group {
  background: rgba(10, 18, 46, 0.9);
  border-radius: 0.55rem;
  padding: 0.4rem 0.5rem 0.35rem;
  min-width: 150px;
}

.wallet-filter-group-title {
  font-size: 0.75rem;
  font-weight: 600;
  margin-bottom: 0.2rem;
}

.wallet-filter-option {
  font-size: 0.7rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  margin-bottom: 0.15rem;
}

.wallet-filter-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.4rem;
}

/* Assets grid */
.wallet-assets-grid {
  margin-top: 0.4rem;
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  max-height: 320px;
  overflow-y: auto;
  padding-right: 0.25rem;
}

.wallet-asset-card {
  width: 120px;
  border-radius: 0.6rem;
  border: 1px solid rgba(120, 141, 255, 0.35);
  background: rgba(7, 12, 30, 0.95);
  padding: 0.35rem 0.4rem 0.45rem;
  font-size: 0.75rem;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  transition: box-shadow 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
}

.wallet-asset-card:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 18px rgba(0, 0, 0, 0.6);
}

.wallet-asset-card.selected {
  border-color: #7cffb3;
  box-shadow: 0 0 0 1px rgba(124, 255, 179, 0.7);
}

.wallet-asset-thumb {
  width: 100%;
  aspect-ratio: 1/1;
  border-radius: 0.45rem;
  object-fit: cover;
  background: #050810;
}

.wallet-asset-thumb.no-image {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  color: #9aa3d9;
}

    /* ‚ûï Add this block */
.thumb-media-html,
.thumb-media-img {
  width: 100%;
  height: 100%;
  border: none;
  display: block;
}

.wallet-asset-title {
  font-weight: 600;
}

.wallet-asset-meta {
  font-size: 0.7rem;
  color: #9aa3d9;
}

.wallet-asset-props {
  margin-top: 0.1rem;
  max-height: 6em;     /* viewport for the scroll */
  overflow-y: auto;    /* ‚¨Ö was `hidden` */
  font-size: 0.7rem;
}


    .prev-search-item {
  padding: 0.35rem 0.5rem;
  border-radius: 0.4rem;
  background: rgba(10, 18, 46, 0.7);
  margin-bottom: 0.25rem;
  cursor: pointer;
}

.prev-search-item:hover {
  background: rgba(20, 30, 70, 0.9);
}

.prev-search-policy {
  font-family: monospace;
  font-size: 0.75rem;
  word-break: break-all;
}

.prev-search-meta {
  font-size: 0.75rem;
  opacity: 0.8;
}

.prev-search-older-toggle {
  font-size: 0.75rem;
  margin-top: 0.25rem;
  cursor: pointer;
  text-decoration: underline;
}
.prev-search-receipt-link {
  font-size: 0.72rem;
  color: #ffc857;
  text-decoration: underline;
  cursor: pointer;
  display: inline-block;
  margin-top: 0.1rem;
}

.prev-search-receipt-link:hover {
  color: #ffe08a;
}



    .table-wrapper {
      max-height: 260px;
      overflow: auto;
      margin-top: 0.5rem;
    }

    .loc-results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    

    .loc-results-table th,
    .loc-results-table td {
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 0.35rem 0.5rem;
      text-align: left;
      word-break: break-all;
    }

    .loc-results-table th {
      background: rgba(10, 18, 46, 0.9);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    /* Collapsible assets list wrapper */
.loc-results-details {
  margin-top: 0.5rem;
  border-radius: 0.6rem;
  border: 1px solid rgba(255, 255, 255, 0.08);
  background: rgba(5, 10, 24, 0.7);
  padding: 0.5rem 0.5rem 0.6rem;
}

/* Slight extra bottom padding only when open */
.loc-results-details[open] {
  padding-bottom: 0.75rem;
}

/* Summary line styling (the clickable header) */
.loc-results-summary {
  list-style: none;
  cursor: pointer;
  font-size: 0.8rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.35rem;
  color: #e4e8ff;
}

/* Hide default marker in some browsers */
.loc-results-summary::-webkit-details-marker {
  display: none;
}

/* Custom caret icon */
.loc-results-summary::before {
  content: '‚ñ∏';
  font-size: 0.75rem;
  opacity: 0.8;
  transition: transform 0.15s ease;
}

/* Rotate caret when the section is open */
.loc-results-details[open] .loc-results-summary::before {
  transform: rotate(90deg);
}

/* Space between summary and table */
.loc-results-details .table-wrapper {
  margin-top: 0.4rem;
}

/* BackUps assets modal */
.backups-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20; /* above gate overlay (z-index:10) */
}

.backups-modal.hidden {
  display: none;
}

.backups-modal-inner {
  background: rgba(5, 10, 24, 0.98);
  border-radius: 0.9rem;
  border: 1px solid rgba(120, 141, 255, 0.3);
  box-shadow: 0 20px 45px rgba(0, 0, 0, 0.85);
  max-width: 960px;
  width: 95%;
  max-height: 80vh;
  padding: 1rem 1.1rem 1.2rem;
  display: flex;
  flex-direction: column;
}

.backups-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.4rem;
}

.backups-modal-close {
  border: none;
  background: rgba(10, 18, 46, 0.95);
  color: #e4e8ff;
  border-radius: 999px;
  width: 32px;
  height: 32px;
  font-size: 1.1rem;
  line-height: 1;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.backups-modal-close:hover {
  background: rgba(120, 141, 255, 0.9);
  color: #050814;
}

.backups-modal-body {
  flex: 1 1 auto;
  min-height: 0;
  margin-top: 0.35rem;
}

/* Let the table use the modal height instead of the smaller card height */
.backups-modal .table-wrapper {
  max-height: 100%;
}

    
    #backupsResultsSummary code {
  font-size: 0.65em; /* roughly half the surrounding text size */
}


    @media (max-width: 800px) {
      .loc-main {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    @media (max-width: 600px) {
      header .container { padding-top: 1.5rem; }
      header h1 { font-size: 1.9rem; }
      .card { margin-top: 1.5rem; padding: 1.5rem; }
      .row { flex-direction: column; align-items: stretch; }
    }
  </style>
</head>
<body>

<!-- Gated area wrapper (shown only after access granted) -->
<div id="protectedArea" class="hidden">
  <!-- Reuse the same logo style in the main app view -->
  <img src="RF5.png" alt="Fre5h Logo" class="brand-logo">

  <div id="backupsContainer" class="loc-container">
    <header class="loc-header">
      <h2 class="loc-title">
        <span class="backups-logo-text">BackUps</span>
        <span class="loc-title-accent">by The Refresh</span>
      </h2>


<p class="loc-subtitle">
        One-click policy ID BackUps, wallet or chain-wide.
      </p>


<div class="loc-substeps">
  <ul>
    <li>Select <strong>Blockchain</strong> or <strong>Connected Wallet</strong>.</li>
    <li>Paste the policy ID you want to BackUp.</li>
    <li>Review the quoted fee and pay if you‚Äôre not a Refresh Whale.</li>
    <li>Once the payment is confirmed, BackUps downloads are unlocked.</li>
  </ul>
</div>

      
    </header>

    <section class="loc-status-block">
      <p class="loc-status loc-status-ok">
        Connected wallet: <span id="backupsWalletShort">‚Äì</span><br/>
        Access type: <span id="backupsAccessType">‚Äì</span>
      </p>
    </section>

    <section class="loc-main">
      <!-- LEFT: controls -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Scan a policy</h3>

<label class="loc-field">
  <span style="display:flex; align-items:center; justify-content:space-between; gap:0.5rem;">
    <span>Policy ID to backup</span>
    <span class="backups-mode-toggle">
      <label style="font-size:0.8rem; display:inline-flex; align-items:center; gap:0.25rem;">
        <input type="radio" name="backupsMode" value="blockchain" checked>
        Blockchain
      </label>
      <label style="font-size:0.8rem; display:inline-flex; align-items:center; gap:0.25rem;">
        <input type="radio" name="backupsMode" value="wallet">
        Connected Wallet
      </label>
    </span>
  </span>
  <input id="backupsPolicyInput"
         type="text"
         placeholder="Paste a 56-character policy ID (no spaces)"/>
</label>

<button type="button" id="backupsScanBtn" class="loc-btn-primary">
  Scan policy on chain
</button>


<p id="backupsHint" class="loc-hint">
  BackUps queries Blockfrost for all assets under this policy and grabs every
  on-chain metadata property it finds. No wallet contents are scanned for this step.
</p>


<details id="backupsPreviousSearches" class="loc-results-details">
  <summary class="loc-results-summary">
    Scan History &amp; Receipts (click to collapse/expand)
  </summary>
  <div id="backupsPrevList" class="loc-hint">
    No previous searches yet.
  </div>
</details>


        </div>
      </div>

      <!-- RIGHT: results + ZIP export -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Results & export</h3>
          <div id="backupsResultsSummary" class="loc-field">
            <span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>
          </div>

<!-- Assets list modal trigger -->
<button type="button"
        id="backupsOpenAssetsModalBtn"
        class="loc-btn-secondary"
        style="margin-top:0.5rem;">
  View assets under this policy
</button>



<div style="display:flex; flex-wrap:wrap; gap:0.5rem; margin-top:0.75rem;">
  <button type="button"
          id="backupsPayBtn"
          class="loc-btn-secondary"
          style="display:none;">
    <!-- label is set in JS -->
    Pay &amp; unlock ZIP
  </button>

  <button type="button"
          id="backupsDownloadZipBtn"
          class="loc-btn-secondary"
          disabled>
    Download BackUps .zip
  </button>
</div>

<!-- üîπ New: logically stacked tracking area at the bottom -->
<div id="backupsStatusStack" class="loc-status-stack">
  <!-- 1) Initial / metadata scan progress -->
  <p id="backupsScanStatus" class="loc-tx-status"></p>

  <!-- 2) Fee + payment / holder info -->
  <p id="backupsFeeStatus" class="loc-tx-status"></p>

  <!-- 3) Quote / ‚Äúone scan‚Äù warning -->
  <p id="backupsQuoteWarning" class="loc-tx-status"></p>

  <!-- 4) ZIP / image download / finalization progress -->
  <p id="backupsDownloadStatus" class="loc-tx-status"></p>
</div>

        </div>
      </div>
    </section>

    <!-- Wallet-mode assets & filters (full width, scrollable) -->
    <section id="walletAssetsSection" class="loc-status-block hidden">
      <h3 style="margin-top:0; font-size:0.95rem; margin-bottom:0.4rem;">
        Wallet assets for this policy
      </h3>
      <p id="walletAssetsSummary" class="loc-hint">
        No wallet scan yet. Select ‚ÄúConnected Wallet‚Äù, enter a policy ID, and run a scan.
      </p>

      <details id="walletFilterDetails" class="wallet-filter-details">
  <summary class="wallet-filter-summary">
    <span>Filter by metadata properties (optional)</span>

    <!-- New: Select all checkbox to the right -->
    <label class="wallet-select-all">
      <input type="checkbox" id="walletSelectAllCheckbox" checked>
      <span>Select all</span>
    </label>
  </summary>


        <div id="walletFiltersContainer" class="wallet-filters-container">
          <!-- Filter groups will be injected here -->
        </div>

        <div class="wallet-filter-actions">
          <button type="button" id="walletApplyFiltersBtn" class="loc-btn-secondary">
            Apply filter
          </button>
          <button type="button" id="walletClearFiltersBtn" class="loc-btn-secondary">
            Clear filter
          </button>
        </div>
      </details>

      <div id="walletAssetsGrid" class="wallet-assets-grid">
        <!-- Asset thumbnail cards injected here -->
      </div>
    </section>

    <section class="loc-status-block loc-legal">
      <p class="loc-legal-text">

        The Refresh and/or BackUps are not responsible for what you or anyone,
        that obtains the files and/or images you download, do with those files
        and/or images. This tool accesses decentralized data fully available on
        the blockchain. You are solely responsible for what happens with the
        content you download, what content you decide to download, and whatever
        consequences follow those actions.
      </p>
    </section>

  </div>
</div>

  <!-- Assets list modal -->
<div id="backupsAssetsModal" class="backups-modal hidden">
  <div class="backups-modal-inner">
    <div class="backups-modal-header">
      <h3 style="margin:0; font-size:0.95rem;">
        Assets under this policy
      </h3>
      <button type="button"
              id="backupsAssetsModalClose"
              class="backups-modal-close"
              aria-label="Close assets list">
        √ó
      </button>
    </div>

    <div class="backups-modal-body">
      <div class="table-wrapper">
        <table id="backupsResultsTable" class="loc-results-table hidden">
          <thead>
            <tr>
              <th>Asset Name (ASCII)</th>
              <th>Quantity</th>
              <th>Full Unit</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</div>


<!-- WALLET GATE OVERLAY -->
<div id="gateOverlay">
  <img src="RF5.png" alt="Fre5h Logo" class="brand-logo">

  <header>
    <div class="container">
      <h1><span class="backups-logo-text">BackUps</span></h1>

     <p id="description">
  Refresh Whales holding 25+ OG The Refresh have VIP access with no usage charge.
  Others pay a 10‚Ç≥ minimum, scaled at 10‚Ç≥ per 50 assets per policy BackUp.
</p>

      <p id="instructions"></p>

      <div class="row" id="connectRow">
        <select id="walletSelect">
          <option value="">Select Wallet‚Ä¶</option>
        </select>
        <button id="connectBtn" disabled>Connect Wallet</button>
      </div>

      <div id="walletStatus" class="hidden"></div>
    </div>
  </header>

  <div class="container">
    <div class="card">
<h2>Details</h2>

<div class="access-steps">
  <h3 class="gate-subtitle">How BackUps works</h3>
  <ul class="gate-list">
    <li>Select <strong>Blockchain</strong> or <strong>Connected Wallet</strong>.</li>
    <li>Paste the policy ID you want to BackUp.</li>
    <li>Review the quoted fee and pay if you‚Äôre not a Refresh Whale.</li>
    <li>Once the payment is confirmed, BackUps downloads are unlocked.</li>
  </ul>
</div>


<div class="access-steps">
  <h3 class="gate-subtitle">BackUps download includes</h3>
  <ul class="gate-list">
    <li>Complete metadata for each individual asset, with policy IDs and IPFS links exactly as they are on-chain.</li>
    <li>Full collection metadata with policy ID and IPFS preserved as-is.</li>
    <li>Images and files saved with filenames tied to their corresponding asset.</li>
    <li>A CSV with a collection-wide breakdown of assets and metadata.</li>
    <li>Downloadable receipts.</li>
    <li>History of previous scans and purchases.</li>
  </ul>
</div>

<p id="gateBlurb" class="loc-hint"></p>

      <p id="accessMessage" class="access-message"></p>

      <!-- Shown only if policy requirements are NOT met -->
<button id="payAccessBtn" style="display:none;">
  Enter BackUps
</button>

    </div>
  </div>
</div>


<!-- JSZip + FileSaver for ZIP export (no integrity to avoid mismatch blocking) -->
<script src="jszip.min.js"></script>
<script src="FileSaver.min.js"></script>


<script type="module">
import {
  BrowserWallet,
  Transaction,
} from 'https://esm.sh/@meshsdk/core@1.9.0-beta.62?bundle';

const sel           = document.getElementById('walletSelect');
const btn           = document.getElementById('connectBtn');
const walletStatus  = document.getElementById('walletStatus');
const accessMessage = document.getElementById('accessMessage');
const gateOverlay   = document.getElementById('gateOverlay');
const protectedArea = document.getElementById('protectedArea');

const instructionsEl = document.getElementById('instructions');
const gateBlurbEl    = document.getElementById('gateBlurb');
const payAccessBtn   = document.getElementById('payAccessBtn');

// TODO: replace with your real receive address (no extra text)
const GATE_RECIPIENT_ADDRESS =
  'addr1q9m2reerla2ccrkwz57rhwl7q8vj8y38x39nv4mq56ppjqmzs7jlke6nm3thlvvddtsnp52s62u0337y9h6d2gmma2wsmjx8nh';

// =========================================================
// Pricing / Fees
// 10‚Ç≥ per 50 assets (per policy BackUp), minimum 10‚Ç≥
// Examples:
//  1‚Äì50 assets  -> 10‚Ç≥
// 51‚Äì100 assets -> 20‚Ç≥
// 101‚Äì150       -> 30‚Ç≥
// =========================================================
const ASSETS_PER_BLOCK        = 50;
const ACCESS_FEE_PER_BLOCK_ADA = 10;

function computeBackupsFeeAda(assetCount) {
  if (!assetCount || assetCount <= 0) return 0;
  const blocks = Math.ceil(assetCount / ASSETS_PER_BLOCK);
  const fee    = blocks * ACCESS_FEE_PER_BLOCK_ADA;
  return Math.max(ACCESS_FEE_PER_BLOCK_ADA, fee); // still enforce 10‚Ç≥ minimum
}



// =========================================================
// Blockfrost config for BackUps (policy-based scan)
// =========================================================
const BLOCKFROST_ENDPOINT   = 'https://cardano-mainnet.blockfrost.io/api/v0';
// üîê IMPORTANT: put your mainnet Blockfrost project key here:
const BLOCKFROST_PROJECT_ID = 'mainnetehvvvJVoJUAz5DFJJz2L9fHZmkXlXTMP'; // e.g. 'mainnetXXXXX...'

// =========================================================
// Fre5h / The Refresh holder access requirements
// =========================================================
const ACCESS_POLICIES = [
  {
    policyId: 'adc5716393953403109c335e68c0384238fd19653e960e03afa1fb1f',
    minAssets: 25,
    label: 'OG The Refresh',
    purchaseUrl: 'https://www.jpg.store/collection/therefresh'
  }
];

// mesh / identity state
let meshWallet, userAddress, userIdentity;
let locPassDaysLeft = null;

// BackUps state ‚Äì last scan
let backupsHasScan = false;
let backupsLastPolicyId = '';
let backupsLastRows = [];     // [{ unit, policyId, assetName, quantity, metadata }, ...]
let backupsLastKeys = [];     // sorted list of all metadata keys
let backupsBaseAssets = null; // raw /assets/policy list (no metadata yet)
let backupsPreviousSearches = []; // [{ policyId, assetCount, feeAda, quotedAt }]

let backupsIsHolder = false;                 // true if wallet meets Refresh requirement
let backupsRequiresPayment = false;          // true for non-holders
let backupsPaidForCurrentPolicy = false;     // set to true after successful payment
let backupsCurrentFeeAda = 0;                // dynamic fee for current scan
let backupsCurrentFeeLovelace = '0';
let backupsCurrentAssetCount = 0;

  // Current BackUps mode: full blockchain scan vs wallet-only scan
// 'blockchain' = existing behavior, 'wallet' = only assets in connected wallet
let backupsMode = 'blockchain';

// Wallet-mode view state
let walletAssetsAll = [];            // [{ unit, policyId, nameHex, assetName, quantity, metadata, imageUrl }, ...]
let walletSelectedUnits = new Set(); // Set<string> of unit
let walletFilterState = {};          // { [propKey: string]: Set<string> }



// ---------------------------------------------------------
// Helper text for gate
// ---------------------------------------------------------
function buildRequirementsLine() {
  return ACCESS_POLICIES
    .map(p => `${p.minAssets} ${p.label}`)
    .join(' + ');
}

function buildRequirementsDetail(foundMap) {
  return ACCESS_POLICIES
    .map(p => {
      const found = foundMap[p.policyId] ?? 0;
      return `${p.label}: ${found} / ${p.minAssets}`;
    })
    .join('\n');
}

function getPrimaryPurchaseUrl() {
  return (ACCESS_POLICIES[0] && ACCESS_POLICIES[0].purchaseUrl) || 'https://www.jpg.store/';
}

// Set gate text
instructionsEl.textContent = `Connect a Cardano wallet to continue.`;
gateBlurbEl.textContent =
  `If your wallet holds at least ${buildRequirementsLine()}, you have VIP BackUps access with no additional fee.`;

// ---------------------------------------------------------
// Mesh wallet detection
// ---------------------------------------------------------
async function detect() {
  try {
    const wallets = await BrowserWallet.getInstalledWallets();

    if (!wallets.length) {
      sel.innerHTML = '<option>(no wallets detected)</option>';
      return;
    }

    // Prefer "mesh" if present
    wallets.sort((a, b) =>
      a.id === 'mesh' ? -1 : b.id === 'mesh' ? 1 : 0
    );

    sel.innerHTML = wallets
      .map((w) => `<option value="${w.id}">${w.name}</option>`)
      .join('');

    sel.value = wallets[0].id;
    btn.disabled = false;
  } catch (err) {
    console.error('Wallet detection failed:', err);
    sel.innerHTML = '<option>(wallet detection failed)</option>';
  }
}

// ---------------------------------------------------------
// Paid access tracking via loc_access.php (same pattern as LOC)
// ---------------------------------------------------------
async function checkPaidAccessStatus() {
  if (!userIdentity) return null;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'check',
        identity: userIdentity,
      }),
    });

    if (!res.ok) {
      console.error('[BackUps] checkPaidAccessStatus HTTP error:', res.status);
      return null;
    }

    const data = await res.json();
    console.log('[BackUps] checkPaidAccessStatus response:', data);

    if (data.status === 'active') {
      return data; // { status, lastPaidDate, expiresOn }
    }

    return null;
  } catch (err) {
    console.error('[BackUps] checkPaidAccessStatus error:', err);
    return null;
  }
}

async function logPaidAccess(txHash) {
  if (!userIdentity) return;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'log',
        identity: userIdentity,
        txHash,
      }),
    });

    const data = await res.json().catch(() => null);
    console.log('[BackUps] logPaidAccess response:', data);
  } catch (err) {
    console.error('[BackUps] logPaidAccess error:', err);
  }
}

// ---------------------------------------------------------
// Small helpers
// ---------------------------------------------------------
function shortenAddress(addr) {
  if (!addr || typeof addr !== 'string') return '‚Äì';
  if (addr.length <= 16) return addr;
  return addr.slice(0, 8) + '‚Ä¶' + addr.slice(-8);
}

function hexToAscii(hex) {
  if (!hex || typeof hex !== 'string') return '';
  let str = '';
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.slice(i, i + 2), 16);
    if (!Number.isNaN(code)) {
      str += String.fromCharCode(code);
    }
  }
  return str;
}

// Minimal CBOR decoder for hex-encoded CBOR (maps/arrays/text/booleans/null).
// This is enough for things like the "socials" field.
const _utf8Decoder = (typeof TextDecoder !== 'undefined')
  ? new TextDecoder('utf-8')
  : null;

function cborReadUint(bytes, offset, nBytes) {
  if (offset + nBytes > bytes.length) {
    throw new Error('CBOR: truncated uint');
  }
  let val = 0;
  for (let i = 0; i < nBytes; i++) {
    val = (val << 8) | bytes[offset + i];
  }
  return { value: val, offset: offset + nBytes };
}

function cborReadArg(addInfo, bytes, offset) {
  if (addInfo < 24) {
    return { value: addInfo, offset };
  }
  if (addInfo === 24) {
    return cborReadUint(bytes, offset, 1);
  }
  if (addInfo === 25) {
    return cborReadUint(bytes, offset, 2);
  }
  if (addInfo === 26) {
    return cborReadUint(bytes, offset, 4);
  }
  if (addInfo === 27) {
    return cborReadUint(bytes, offset, 8);
  }
  if (addInfo === 31) {
    throw new Error('CBOR: indefinite-length not supported');
  }
  throw new Error('CBOR: unsupported additional info ' + addInfo);
}

  function isPrintableAscii(str) {
  return /^[\x20-\x7E]*$/.test(str);
}


function decodeCborItem(bytes, offset) {
  if (offset >= bytes.length) {
    throw new Error('CBOR: unexpected end of data');
  }

  const initial = bytes[offset++];
  const major   = initial >> 5;
  const addInfo = initial & 0x1f;

  switch (major) {
    case 0: { // unsigned int
      const { value, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      return { value, offset: off2 };
    }

    case 1: { // negative int
      const { value, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      return { value: -1 - value, offset: off2 };
    }

    case 2: { // byte string
      const { value: len, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      if (off2 + len > bytes.length) {
        throw new Error('CBOR: truncated byte string');
      }
      const buf = bytes.slice(off2, off2 + len);

      // Try to decode as UTF-8 text. If it's clean printable ASCII, treat it as a string.
      if (_utf8Decoder) {
        try {
          const text = _utf8Decoder.decode(buf);
          if (isPrintableAscii(text)) {
            return { value: text, offset: off2 + len };
          }
        } catch (e) {
          // fall through to raw bytes
        }
      }

      // Otherwise keep as Uint8Array (binary data)
      return { value: buf, offset: off2 + len };
    }


    case 3: { // text string
      const { value: len, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      if (off2 + len > bytes.length) {
        throw new Error('CBOR: truncated text string');
      }
      const buf = bytes.slice(off2, off2 + len);
      let str;
      if (_utf8Decoder) {
        str = _utf8Decoder.decode(buf);
      } else {
        // very basic fallback
        str = Array.from(buf).map(ch => String.fromCharCode(ch)).join('');
      }
      return { value: str, offset: off2 + len };
    }

    case 4: { // array
      const { value: len, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      const arr = [];
      let cur = off2;
      for (let i = 0; i < len; i++) {
        const item = decodeCborItem(bytes, cur);
        arr.push(item.value);
        cur = item.offset;
      }
      return { value: arr, offset: cur };
    }

    case 5: { // map
      const { value: len, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      const obj = {};
      let cur = off2;
      for (let i = 0; i < len; i++) {
        const kItem = decodeCborItem(bytes, cur);
        cur = kItem.offset;
        const vItem = decodeCborItem(bytes, cur);
        cur = vItem.offset;
        const key = (typeof kItem.value === 'string')
          ? kItem.value
          : String(kItem.value);
        obj[key] = vItem.value;
      }
      return { value: obj, offset: cur };
    }

    case 6: { // tag ‚Äì ignore tag, decode inner value
      const { value: _tag, offset: off2 } = cborReadArg(addInfo, bytes, offset);
      const inner = decodeCborItem(bytes, off2);
      return { value: inner.value, offset: inner.offset };
    }

    case 7: { // simple/float ‚Äì handle only common constants
      if (addInfo === 20) return { value: false, offset };
      if (addInfo === 21) return { value: true, offset };
      if (addInfo === 22) return { value: null, offset };
      if (addInfo === 23) return { value: undefined, offset };
      throw new Error('CBOR: unsupported simple/float');
    }

    default:
      throw new Error('CBOR: unsupported major type ' + major);
  }
}

function tryDecodeCborHex(hex) {
  if (!hex || typeof hex !== 'string') return null;
  if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 2 !== 0) return null;

  try {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
      const b = parseInt(hex.substr(i * 2, 2), 16);
      if (Number.isNaN(b)) return null;
      bytes[i] = b;
    }
    const { value } = decodeCborItem(bytes, 0);
    return value;
  } catch (e) {
    console.warn('[BackUps] CBOR decode failed, leaving as hex:', e);
    return null;
  }
}


function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

  // ---------------------------------------------------------
// Detect B64
// ---------------------------------------------------------
  function getInlineDataUriFromMetadata(meta) {
  if (!meta || typeof meta !== 'object') return null;

  // 1) Try CIP-25 / CIP-68 style `files[0].src`
  const files = meta.files;
  if (Array.isArray(files) && files.length > 0 && files[0] && files[0].src) {
    const raw = Array.isArray(files[0].src) ? files[0].src.join('') : files[0].src;
    if (typeof raw === 'string' && raw.startsWith('data:')) {
      return raw;
    }
  }

  // 2) Fallbacks: src / image_data / image
  const candidateKeys = ['src', 'image_data', 'image'];
  for (const key of candidateKeys) {
    const val = meta[key];
    if (!val) continue;

    const raw = Array.isArray(val) ? val.join('') : val;
    if (typeof raw === 'string' && raw.startsWith('data:')) {
      return raw;
    }
  }

  return null;
}

  function buildBase64ThumbMedia(meta) {
  const dataUri = getInlineDataUriFromMetadata(meta);
  if (!dataUri) return ''; // no inline base64 found, let existing logic handle it

  // HTML on-chain
  if (dataUri.startsWith('data:text/html')) {
    return `
      <iframe 
        src="${dataUri}" 
        class="thumb-media thumb-media-html" 
        loading="lazy"
      ></iframe>`;
  }

  // Image on-chain (png, svg+xml, jpeg, etc)
  if (dataUri.startsWith('data:image/')) {
    return `
      <img 
        src="${dataUri}" 
        class="thumb-media thumb-media-img" 
        loading="lazy"
      />`;
  }

  // Other data types -> let your existing thumbnail system do its thing
  return '';
}



function buildPropertiesSnippet(meta) {
  if (!meta || typeof meta !== 'object') return '';

  // Hide technical / heavy fields from thumbnail previews.
  // We still keep them in the JSON / CSV / ZIP.
  const HIDDEN_KEYS = new Set([
    'name',
    'image',
    'image_data',
    'files',
    'file',
    'src',
    'mediaType',
    'media_type',
    'mimeType',
    'mime_type',
    'ipfs',
    'ipfs_hash',
    'url',
    'website',
    'twitter',
    'discord',
    'policy',
    'policyId',
    'policy_id',
    'asset',
    'assetId',
    'asset_id',
    'assetName',
    'asset_name',
  ]);

  const entries = Object.entries(meta)
    .filter(([k]) => !HIDDEN_KEYS.has(k))   // keep rarity / traits, etc.
    .slice(0, 5);                           // same cap as before

  if (!entries.length) return '';

  return entries
    .map(([k, v]) => {
      const normVal = normalizeMetadataValue(v);
      const valStr = typeof normVal === 'object'
        ? JSON.stringify(normVal)
        : String(normVal);
      return `<div><strong>${escapeHtml(k)}:</strong> ${escapeHtml(valStr)}</div>`;
    })
    .join('');
}


function matchesWalletFilters(asset) {
  if (!walletFilterState || !Object.keys(walletFilterState).length) return true;
  const meta = asset.metadata || {};

  for (const key of Object.keys(walletFilterState)) {
    const set = walletFilterState[key];
    if (!set || !set.size) continue;

    const rawVal = meta[key];
    const normVal = normalizeMetadataValue(rawVal);
    const valStr = typeof normVal === 'object'
      ? JSON.stringify(normVal)
      : String(normVal);

    if (!set.has(valStr)) {
      return false;
    }
  }
  return true;
}

function buildWalletFiltersUI() {
  const filtersContainer = document.getElementById('walletFiltersContainer');
  if (!filtersContainer) return;

  filtersContainer.innerHTML = '';

  if (!walletAssetsAll.length) {
    filtersContainer.textContent = 'No assets to filter yet.';
    return;
  }

  const propMap = {};
  for (const asset of walletAssetsAll) {
    const meta = asset.metadata || {};
    for (const key of Object.keys(meta)) {
      if (key === 'name' || key === 'image') continue;
      const normVal = normalizeMetadataValue(meta[key]);
      const valStr = typeof normVal === 'object'
        ? JSON.stringify(normVal)
        : String(normVal);
      if (!propMap[key]) propMap[key] = {};
      if (!propMap[key][valStr]) propMap[key][valStr] = 0;
      propMap[key][valStr]++;
    }
  }

  const keys = Object.keys(propMap).sort();
  if (!keys.length) {
    filtersContainer.textContent = 'No extra properties found to filter on.';
    return;
  }

  const groupsWrapper = document.createElement('div');
  groupsWrapper.className = 'wallet-filters-grid';

  keys.forEach((key) => {
    const group = document.createElement('div');
    group.className = 'wallet-filter-group';

    const title = document.createElement('div');
    title.className = 'wallet-filter-group-title';
    title.textContent = key;
    group.appendChild(title);

    const values = Object.entries(propMap[key]).sort(
      (a, b) => a[0].localeCompare(b[0])
    );

    values.forEach(([valStr, count]) => {
      const label = document.createElement('label');
      label.className = 'wallet-filter-option';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.dataset.key = key;
      cb.dataset.value = valStr;

      label.appendChild(cb);
      label.appendChild(document.createTextNode(` ${valStr} (${count})`));
      group.appendChild(label);
    });

    groupsWrapper.appendChild(group);
  });

  filtersContainer.appendChild(groupsWrapper);
}


  function setBackupsMode(mode) {
  backupsMode = mode === 'wallet' ? 'wallet' : 'blockchain';

  const walletSection   = document.getElementById('walletAssetsSection');
  const scanBtn         = document.getElementById('backupsScanBtn');
  const summary         = document.getElementById('backupsResultsSummary');
  const feeStatus       = document.getElementById('backupsFeeStatus');
  const scanStatus      = document.getElementById('backupsScanStatus');
  const quoteWarn       = document.getElementById('backupsQuoteWarning');
  const downloadStatus  = document.getElementById('backupsDownloadStatus');
  const table           = document.getElementById('backupsResultsTable');
  const tbody           = table?.querySelector('tbody');
  const payBtn          = document.getElementById('backupsPayBtn');
  const zipBtn          = document.getElementById('backupsDownloadZipBtn');
  const hint            = document.getElementById('backupsHint');

  // Reset shared BackUps state
  backupsHasScan = false;
  backupsLastPolicyId = '';
  backupsLastRows = [];
  backupsLastKeys = [];
  backupsBaseAssets = null;
  backupsCurrentAssetCount = 0;
  backupsCurrentFeeAda = 0;
  backupsCurrentFeeLovelace = '0';

  // Reset wallet-specific state
  walletAssetsAll = [];
  walletSelectedUnits = new Set();
  walletFilterState = {};

  if (walletSection) {
    if (backupsMode === 'wallet') {
      walletSection.classList.remove('hidden');
    } else {
      walletSection.classList.add('hidden');
    }
  }

  if (tbody) tbody.innerHTML = '';
  if (table) table.classList.add('hidden');
  if (feeStatus) feeStatus.textContent = '';
  if (scanStatus) scanStatus.textContent = '';
  if (quoteWarn) quoteWarn.textContent = '';
  if (downloadStatus) downloadStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }
  if (zipBtn) zipBtn.disabled = true;

  if (scanBtn) {
    scanBtn.disabled = false;
    scanBtn.textContent =
      backupsMode === 'wallet'
        ? 'Scan policy (wallet)'
        : 'Scan policy on chain';
  }

  if (summary) {
    summary.innerHTML =
      backupsMode === 'wallet'
        ? '<span>No wallet scan yet. Select ‚ÄúConnected Wallet‚Äù, paste a policy ID, then press ‚ÄúScan policy (wallet)‚Äù.</span>'
        : '<span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>';
  }

  const walletSummary = document.getElementById('walletAssetsSummary');
  if (walletSummary) {
    walletSummary.textContent =
      'No wallet scan yet. Select ‚ÄúConnected Wallet‚Äù, enter a policy ID, and run a scan.';
  }

    if (hint) {
    if (backupsMode === 'wallet') {
      hint.textContent =
        'BackUps scans your connected wallet for assets under this policy and fetches their on-chain metadata. Your wallet contents are scanned for this step.';
    } else {
      hint.textContent =
        'BackUps queries Blockfrost for all assets under this policy and grabs every on-chain metadata property it finds. No wallet contents are scanned for this step.';
    }
  }
}

function renderWalletAssetsView() {
  const gridEl     = document.getElementById('walletAssetsGrid');
  const summaryEl  = document.getElementById('walletAssetsSummary');
  const policyInput = document.getElementById('backupsPolicyInput');

  if (!gridEl || !summaryEl) return;

  gridEl.innerHTML = '';

  if (!walletAssetsAll.length) {
    summaryEl.textContent =
      'No assets to display yet. Run a wallet scan for a policy ID first.';
    return;
  }

  const total = walletAssetsAll.length;
  const selectedCount = walletSelectedUnits.size;

  // Sync the "Select all" checkbox with current selection
  const selectAllCheckbox = document.getElementById('walletSelectAllCheckbox');
  if (selectAllCheckbox) {
    selectAllCheckbox.checked =
      total > 0 && selectedCount === total && selectedCount > 0;
  }

  const filteredAssets = walletAssetsAll.filter(matchesWalletFilters);


  // Render cards
  for (const asset of filteredAssets) {
    const card = document.createElement('div');
    card.className = 'wallet-asset-card';
    if (walletSelectedUnits.has(asset.unit)) {
      card.classList.add('selected');
    }

// üîπ First, try to build a base64 on-chain thumbnail (HTML or image)
const base64Thumb = buildBase64ThumbMedia(asset.metadata);

let thumbHtml = '';
if (base64Thumb) {
  // Wrap your base64 view in the same frame used for normal thumbs
  thumbHtml = `
    <div class="wallet-asset-thumb">
      ${base64Thumb}
    </div>`;
} else if (asset.imageUrl) {
  // Fallback to regular image URL (IPFS/HTTP)
  thumbHtml = `<img src="${asset.imageUrl}" alt="Asset preview" class="wallet-asset-thumb">`;
} else {
  // Last resort: no image
  thumbHtml = `<div class="wallet-asset-thumb no-image">No image</div>`;
}

const propsHtml = buildPropertiesSnippet(asset.metadata);

card.innerHTML = `
  ${thumbHtml}
  <div class="wallet-asset-title">${escapeHtml(asset.assetName || '(no name)')}</div>
  <div class="wallet-asset-meta">Qty: ${asset.quantity}</div>
  <div class="wallet-asset-props">${propsHtml}</div>
`;


    card.addEventListener('click', () => {
      if (walletSelectedUnits.has(asset.unit)) {
        walletSelectedUnits.delete(asset.unit);
      } else {
        walletSelectedUnits.add(asset.unit);
      }
      renderWalletAssetsView(); // re-render selection + fee
    });

    gridEl.appendChild(card);
  }

  const filteredCount = filteredAssets.length;
  const feeAda = computeBackupsFeeAda(selectedCount);

  const filterPart =
    filteredCount === total
      ? `Showing all ${total} asset(s) from your wallet for this policy.`
      : `Showing ${filteredCount} of ${total} asset(s) based on current filters.`;

  const selectedPart =
    selectedCount > 0
      ? `Selected ${selectedCount} asset(s).`
      : 'No assets selected yet.';

  const feePart = selectedCount
    ? (backupsIsHolder
        ? 'You are a Refresh holder ‚Äì no BackUps fee for this selection.'
        : `BackUps fee for this selection: ${feeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).`)
    : '';

  summaryEl.textContent =
    `${filterPart} ${selectedPart}${feePart ? ' ' + feePart : ''}`;

  // Sync BackUps core state so "Results & export" behaves identically,
  // but based on selected wallet assets instead of a chain-wide scan.
  const selectedRows = walletAssetsAll
    .filter(a => walletSelectedUnits.has(a.unit))
    .map(a => ({
      unit: a.unit,
      policyId: a.policyId,
      nameHex: a.nameHex,
      assetName: a.assetName,
      quantity: a.quantity,
      metadata: a.metadata,
    }));

  const keysSet = new Set();
  selectedRows.forEach(row => {
    const meta = row.metadata || {};
    Object.keys(meta).forEach(k => keysSet.add(k));
  });

  backupsLastPolicyId       = (policyInput?.value || '').trim();
  backupsLastRows           = selectedRows;
  backupsLastKeys           = Array.from(keysSet).sort();
  backupsHasScan            = selectedRows.length > 0;
  backupsCurrentAssetCount  = selectedRows.length;
  backupsCurrentFeeAda      = feeAda;
  backupsCurrentFeeLovelace = String(feeAda * 1_000_000);

  if (selectedRows.length) {
    // Use your existing renderer for "Results & export" panel + fee/pay logic
    renderBackupsResults();
  } else {
    // No assets selected => reset "Results & export" so it doesn't say "no assets on chain"
    const summary   = document.getElementById('backupsResultsSummary');
    const feeStatus = document.getElementById('backupsFeeStatus');
    const zipBtn    = document.getElementById('backupsDownloadZipBtn');
    const payBtn    = document.getElementById('backupsPayBtn');
    const table     = document.getElementById('backupsResultsTable');
    const tbody     = table?.querySelector('tbody');

    if (summary) {
      summary.innerHTML =
        '<span>Select at least one asset from your wallet below to generate a BackUps quote.</span>';
    }
    if (feeStatus) feeStatus.textContent = '';
    if (zipBtn) zipBtn.disabled = true;
    if (payBtn) {
      payBtn.style.display = 'none';
      payBtn.disabled = false;
    }
    if (tbody) tbody.innerHTML = '';
    if (table) table.classList.add('hidden');
  }
}



async function loadPreviousSearches() {
  if (!userIdentity) return;

  try {
    const res = await fetch('backups_searches.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'list',
        identity: userIdentity,
      }),
    });

    if (!res.ok) return;

    const data = await res.json().catch(() => null);
    if (!data || !Array.isArray(data.searches)) return;

    backupsPreviousSearches = data.searches;
    renderPreviousSearches();
  } catch (err) {
    console.warn('[BackUps] loadPreviousSearches error:', err);
  }
}

async function savePreviousSearch(policyId, assetCount, feeAda, extras = {}) {
  if (!userIdentity || !policyId) return;

  const existingIndex = backupsPreviousSearches.findIndex(
    (s) => s.policyId === policyId
  );
  const now = Date.now();
  let record;

  if (existingIndex >= 0) {
    const existing = backupsPreviousSearches[existingIndex] || {};
    record = {
      ...existing,
      policyId,
      assetCount,
      feeAda,
      quotedAt: now,
      ...extras, // may include paidFeeAda, paidAt, paidTxHash, paidAddress
    };
    backupsPreviousSearches[existingIndex] = record;
  } else {
    record = {
      policyId,
      assetCount,
      feeAda,
      quotedAt: now,
      ...extras,
    };
    backupsPreviousSearches.push(record);
  }

  // keep newest first locally
  backupsPreviousSearches.sort(
    (a, b) => (b.quotedAt || 0) - (a.quotedAt || 0)
  );
  renderPreviousSearches();

  try {
    await fetch('backups_searches.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'save',
        identity: userIdentity,
        search: record,
      }),
    });
  } catch (err) {
    console.warn('[BackUps] savePreviousSearch error:', err);
  }
}


function renderPreviousSearches() {
  const wrapper = document.getElementById('backupsPrevList');
  if (!wrapper) return;

  if (!backupsPreviousSearches.length) {
    wrapper.textContent = 'No previous searches yet.';
    return;
  }

  wrapper.innerHTML = '';

  const maxAlwaysVisible = 3;
  const visibles = backupsPreviousSearches.slice(0, maxAlwaysVisible);
  const older   = backupsPreviousSearches.slice(maxAlwaysVisible);

const makeItem = (s) => {
  const div = document.createElement('div');
  div.className = 'prev-search-item';

  const paidFeeLabel =
    s.paidFeeAda != null && s.paidFeeAda > 0 ? `${s.paidFeeAda}‚Ç≥` : '‚Äì';

  div.innerHTML = `
    <div class="prev-search-policy">${s.policyId}</div>
    <div class="prev-search-meta">
      ${s.assetCount} asset(s) ‚Ä¢ quoted fee ${s.feeAda}‚Ç≥ ‚Ä¢ paid fee ${paidFeeLabel}
    </div>
    <div class="prev-search-meta">
      ${
        s.paidFeeAda != null && s.paidFeeAda > 0 && s.paidTxHash
          ? '<span class="prev-search-receipt-link">Download Receipt</span>'
          : ''
      }
    </div>
  `;

  // Clicking the whole row = reuse quote
  div.addEventListener('click', () => {
    const input = document.getElementById('backupsPolicyInput');
    if (input) input.value = s.policyId;
    runQuotedScanFlow(s);
  });

  // Clicking "Download Receipt" only downloads, doesn‚Äôt trigger scan
  const receiptLink = div.querySelector('.prev-search-receipt-link');
  if (receiptLink) {
    receiptLink.addEventListener('click', (evt) => {
      evt.stopPropagation();
      downloadReceiptForSearch(s);
    });
  }

  return div;
};


  visibles.forEach((s) => wrapper.appendChild(makeItem(s)));

  if (older.length) {
    const olderToggle = document.createElement('div');
    olderToggle.className = 'prev-search-older-toggle';
    olderToggle.textContent = 'Show older searches';
    let expanded = false;

    olderToggle.addEventListener('click', () => {
      expanded = !expanded;
      olderToggle.textContent = expanded
        ? 'Hide older searches'
        : 'Show older searches';

      if (expanded) {
        older.forEach((s) => wrapper.appendChild(makeItem(s)));
      } else {
        // re-render to collapse
        renderPreviousSearches();
      }
    });

    wrapper.appendChild(olderToggle);
  }
}

function runQuotedScanFlow(search) {
  const statusEl  = document.getElementById('backupsScanStatus');
  const summary   = document.getElementById('backupsResultsSummary');
  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const quoteWarn = document.getElementById('backupsQuoteWarning');
  const scanBtn   = document.getElementById('backupsScanBtn');

  // Reset core BackUps state based on the stored quote
  backupsHasScan              = false;
  backupsLastPolicyId         = search.policyId;
  backupsLastRows             = [];
  backupsLastKeys             = [];
  backupsBaseAssets           = null;
  backupsCurrentAssetCount    = search.assetCount;
  backupsCurrentFeeAda        = search.feeAda;
  backupsCurrentFeeLovelace   = String(search.feeAda * 1_000_000);
  backupsPaidForCurrentPolicy = backupsIsHolder; // holders still free

  if (zipBtn) zipBtn.disabled = true;

  if (statusEl) {
    statusEl.textContent =
      'Reusing your previous BackUps quote for this policy.\nFetching current assets and metadata so the asset list is available‚Ä¶';
  }

  if (summary) {
    summary.innerHTML =
      `<span>Policy <code>${search.policyId}</code> has a quoted total of <strong>${search.assetCount}</strong> asset(s).</span>`;
  }

  if (feeStatus) {
    if (backupsIsHolder) {
      feeStatus.textContent =
        `You are a Refresh holder (‚â• ${ACCESS_POLICIES[0].minAssets}). No BackUps fee for this policy.`;
    } else if (search.feeAda > 0) {
      feeStatus.textContent =
        `Quoted BackUps fee for this policy is ${search.feeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).\n` +
        `Press ‚ÄúPay & unlock ZIP‚Äù to proceed.`;
    } else {
      feeStatus.textContent =
        'No assets under this policy in your previous quote.';
    }
  }

  if (quoteWarn) {
    quoteWarn.textContent =
      'This quote is based on the asset count shown above.\n' +
      'If more assets are minted after this quote, you may be asked to pay the difference before the ZIP can be downloaded.';
  }

  if (payBtn) {
    if (!backupsIsHolder && search.feeAda > 0) {
      payBtn.textContent = `Pay ${search.feeAda}‚Ç≥ & unlock ZIP`;
      payBtn.style.display = 'inline-flex';
      payBtn.disabled = false;
    } else {
      payBtn.style.display = 'none';
    }
  }

  // üîπ Keep the ‚Äúone quote‚Äù behavior, but still load metadata for the asset list
  if (scanBtn) {
    scanBtn.disabled = true;
  }

  // üîπ NEW: run a metadata scan so "Assets under this policy" modal has rows
  // This re-fetches assets/metadata, but ZIP download is still gated by payment.
  scanMetadataForCurrentPolicy(
    document.getElementById('backupsDownloadStatus') || statusEl || null
  );
}



// ---------------------------------------------------------
// Blockfrost policy-wide scan helpers for BackUps
// ---------------------------------------------------------
async function fetchAllAssetsForPolicy(policyId) {
  if (!BLOCKFROST_PROJECT_ID) {
    throw new Error('Blockfrost project ID is not configured.');
  }
  let page = 1;
  let all = [];

  while (true) {
    const res = await fetch(
      `${BLOCKFROST_ENDPOINT}/assets/policy/${policyId}?page=${page}`,
      { headers: { project_id: BLOCKFROST_PROJECT_ID } }
    );

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`Blockfrost error ${res.status}: ${text}`);
    }

    const chunk = await res.json();
    if (!Array.isArray(chunk) || chunk.length === 0) break;

    all = all.concat(chunk);
    page++;
  }

  return all; // each entry has .asset (unit), .quantity, ...
}

async function fetchMetadataForAsset(unit) {
  const res = await fetch(
    `${BLOCKFROST_ENDPOINT}/assets/${unit}`,
    { headers: { project_id: BLOCKFROST_PROJECT_ID } }
  );

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.warn(`Blockfrost /assets/${unit} error ${res.status}: ${text}`);
    return {};
  }

  const data = await res.json();
  return data.onchain_metadata || {};
}

async function scanMetadataForCurrentPolicy(statusEl) {
  if (!backupsLastPolicyId) return;
  
    const downloadStatusEl = document.getElementById('backupsDownloadStatus');
  const headerLineForScan =
    'Processing BackUps request‚Ä¶ Fetching asset metadata and preparing ZIP‚Ä¶';


  const policyId = backupsLastPolicyId;

  let baseAssets = backupsBaseAssets;
  if (!Array.isArray(baseAssets) || baseAssets.length === 0) {
    baseAssets = await fetchAllAssetsForPolicy(policyId);
    backupsBaseAssets = baseAssets;
  }

  const allKeys = new Set();
  const rows    = [];
  const total   = baseAssets.length;

  for (let i = 0; i < total; i++) {
    const base = baseAssets[i];
    const unit = base.asset; // full hex unit (policy + name)
    const quantity = String(base.quantity ?? '0');

    const policyHex = unit.slice(0, 56);
    const nameHex   = unit.slice(56);
    const assetName = hexToAscii(nameHex) || '(no ASCII name)';

    if (statusEl) {
      if (statusEl === downloadStatusEl) {
        statusEl.innerHTML =
          `<strong>${headerLineForScan}</strong><br>` +
          `<span style="opacity:0.85;">Scanning ${i + 1} / ${total}‚Ä¶</span>`;
      } else {
        statusEl.textContent = `Scanning ${i + 1} / ${total}‚Ä¶`;
      }
    }


  const metadata = await fetchMetadataForAsset(unit);

  // üî¥ If there is no metadata at all ‚Äì skip it
  if (!metadata || Object.keys(metadata).length === 0) {
    continue;
  }

  // üî¥ Require a proper name in metadata
  const metaNameRaw = (typeof metadata.name === 'string') ? metadata.name.trim() : '';

  // if there's no name we don't want it
  if (!metaNameRaw) {
    continue;
  }

  // store this as the assetName we use everywhere
  const assetNameClean = metaNameRaw;

  Object.keys(metadata).forEach(k => allKeys.add(k));

  rows.push({
    unit,
    policyId: policyHex,
    nameHex,
    assetName: assetNameClean,   // this is now ALWAYS metadata.name
    quantity,
    metadata,
  });

  }

  backupsHasScan  = true;
  backupsLastRows = rows;
  backupsLastKeys = Array.from(allKeys).sort();

  renderBackupsResults();
}


function renderBackupsResults() {
  const table    = document.getElementById('backupsResultsTable');
  const tbody    = table?.querySelector('tbody');
  const summary  = document.getElementById('backupsResultsSummary');
  const zipBtn   = document.getElementById('backupsDownloadZipBtn');

  if (!table || !tbody || !summary || !zipBtn) return;

  tbody.innerHTML = '';

  if (!backupsHasScan || !backupsLastRows.length) {
    table.classList.add('hidden');
    summary.innerHTML =
      '<span>No assets found for this policy on chain.</span>';
    zipBtn.disabled = true;
    return;
  }

  const count = backupsLastRows.length;
  summary.innerHTML =
    `<span>Found <strong>${count}</strong> asset(s) under policy <code>${backupsLastPolicyId}</code>.</span>`;

  // recompute fee + asset count based on actual rows
  backupsCurrentAssetCount   = count;
  backupsCurrentFeeAda       = computeBackupsFeeAda(count);
  backupsCurrentFeeLovelace  = String(backupsCurrentFeeAda * 1_000_000);
  // NOTE: do NOT touch backupsPaidForCurrentPolicy here ‚Äì it‚Äôs controlled by gate/payment flow


  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');

  if (feeStatus) feeStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }

  // sort by assetName asc
  backupsLastRows.sort((a, b) =>
    (a.assetName || '').localeCompare(b.assetName || '')
  );

  for (const row of backupsLastRows) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.assetName || '(no ASCII name)'}</td>
      <td>${row.quantity}</td>
      <td>${row.unit}</td>
    `;
    tbody.appendChild(tr);
  }

  table.classList.remove('hidden');

  if (backupsIsHolder) {
    if (feeStatus) {
      feeStatus.textContent =
        `You are a Refresh holder (‚â• ${ACCESS_POLICIES[0].minAssets}). No BackUps fee for this policy.`;
    }
    zipBtn.disabled = false;
  } else {
    if (backupsCurrentFeeAda <= 0) {
      if (feeStatus) {
        feeStatus.textContent =
          'No assets under this policy, so there is nothing to pay or download.';
      }
      zipBtn.disabled = true;
    } else if (backupsPaidForCurrentPolicy) {
      // Non-holder, but this policy has already been paid for in this session
      if (feeStatus) {
        feeStatus.textContent =
          `Payment confirmed for this policy.\nYou can now download the BackUps .zip.`;
      }
      if (payBtn) {
        payBtn.style.display = 'none';
      }
      zipBtn.disabled = false;
    } else {
      // Non-holder, not yet paid
      if (feeStatus) {
feeStatus.textContent =
  `This policy has ${count} asset(s).\n` +
  `BackUps fee is ${backupsCurrentFeeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).\n` +
  `Press ‚ÄúPay & unlock ZIP‚Äù to process the transaction.`;

      }
      if (payBtn) {
        payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
        payBtn.style.display = 'inline-flex';
      }
      zipBtn.disabled = true;
    }
  }
}


async function backupsScanForPolicy() {
  const statusEl        = document.getElementById('backupsScanStatus');
  const policyEl        = document.getElementById('backupsPolicyInput');
  const zipBtn          = document.getElementById('backupsDownloadZipBtn');
  const table           = document.getElementById('backupsResultsTable');
  const tbody           = table?.querySelector('tbody');
  const summary         = document.getElementById('backupsResultsSummary');
  const feeStatus       = document.getElementById('backupsFeeStatus');
  const payBtn          = document.getElementById('backupsPayBtn');
  const quoteWarn       = document.getElementById('backupsQuoteWarning');
  const downloadStatus  = document.getElementById('backupsDownloadStatus');

  // reset state for new scan
  if (feeStatus) feeStatus.textContent = '';
  if (quoteWarn) quoteWarn.textContent = '';
  if (statusEl) statusEl.textContent = '';
  if (downloadStatus) downloadStatus.textContent = '';
  backupsHasScan              = false;
  backupsLastPolicyId         = '';
  backupsLastRows             = [];
  backupsLastKeys             = [];
  backupsBaseAssets           = null;
  backupsPaidForCurrentPolicy = backupsIsHolder; // holders effectively "prepaid" (free)
  backupsCurrentAssetCount    = 0;
  backupsCurrentFeeAda        = 0;
  backupsCurrentFeeLovelace   = '0';

  if (zipBtn) zipBtn.disabled = true;
  if (tbody) tbody.innerHTML = '';
  table?.classList.add('hidden');
  if (summary) {
    summary.innerHTML =
      '<span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>';
  }
  if (feeStatus) feeStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }

  const rawPolicy = (policyEl?.value || '').trim();

  // üîπ If this policy was already scanned before, reuse the stored quote
  const existingSearch = backupsPreviousSearches.find(
    (s) => s.policyId === rawPolicy
  );
  if (existingSearch) {
    runQuotedScanFlow(existingSearch);
    const scanBtn = document.getElementById('backupsScanBtn');
    if (scanBtn) scanBtn.disabled = true;
    return; // ‚õî no new Blockfrost scan for the quote itself
  }

  if (!rawPolicy) {
    if (statusEl) statusEl.textContent = 'Enter a policy ID to scan.';
    return;
  }
  if (rawPolicy.length !== 56 && statusEl) {
    statusEl.textContent =
      'Policy ID length looks unusual (not 56 chars). Still scanning in case this is test data‚Ä¶';
  }

  if (!BLOCKFROST_PROJECT_ID) {
    if (statusEl) statusEl.textContent =
      'Blockfrost project ID is not set in the code. Please configure BLOCKFROST_PROJECT_ID.';
    return;
  }

  try {
    if (statusEl) {
      statusEl.textContent = 'Fetching assets for policy via Blockfrost‚Ä¶';
    }

    const baseAssets = await fetchAllAssetsForPolicy(rawPolicy);
    backupsBaseAssets   = baseAssets;
    backupsLastPolicyId = rawPolicy;

    if (!baseAssets.length) {
      if (summary) {
        summary.innerHTML =
          `<span>No assets under policy <code>${rawPolicy}</code> were found on chain.</span>`;
      }
      if (statusEl) {
        statusEl.textContent = 'Scan complete. No assets under this policy.';
      }
      return;
    }

    // ‚≠ê NEW: always run the metadata scan so we ONLY work with "full" assets
    if (statusEl) {
      statusEl.textContent = 'Scanning assets and fetching on-chain metadata‚Ä¶';
    }

    const downloadStatus = document.getElementById('backupsDownloadStatus');
    if (downloadStatus) {
      const headerLine =
        'Processing BackUps request‚Ä¶ Fetching asset metadata and preparing ZIP‚Ä¶';
      downloadStatus.innerHTML =
        `<strong>${headerLine}</strong><br>` +
        `<span style="opacity:0.85;">Preparing metadata files‚Ä¶</span>`;
    }

    await scanMetadataForCurrentPolicy(downloadStatus || statusEl);


    if (statusEl) {
      statusEl.textContent = 'Scan complete.';
    }

    // At this point:
    //   - backupsLastRows = ONLY assets with on-chain metadata + metadata.name
    //   - renderBackupsResults() has already run
    //   - backupsCurrentAssetCount / backupsCurrentFeeAda are based on that filtered list
    //
    // üîπ Store this filtered count + fee as the "quote" for future reuse.
    await savePreviousSearch(
      rawPolicy,
      backupsCurrentAssetCount,
      backupsCurrentFeeAda
    );

  } catch (err) {
    console.error('[BackUps] scan error:', err);
    if (statusEl) {
      statusEl.textContent =
        'An error occurred while scanning. Check console for details.';
    }
  }
}

async function backupsScanWalletPolicy() {
  const statusEl        = document.getElementById('backupsScanStatus');
  const policyEl        = document.getElementById('backupsPolicyInput');
  const summary         = document.getElementById('backupsResultsSummary');
  const walletSummaryEl = document.getElementById('walletAssetsSummary');
  const walletSection   = document.getElementById('walletAssetsSection');
  const feeStatus       = document.getElementById('backupsFeeStatus');
  const quoteWarn       = document.getElementById('backupsQuoteWarning');
  const downloadStatus  = document.getElementById('backupsDownloadStatus');
  const table           = document.getElementById('backupsResultsTable');
  const tbody           = table?.querySelector('tbody');
  const payBtn          = document.getElementById('backupsPayBtn');
  const zipBtn          = document.getElementById('backupsDownloadZipBtn');

  // Basic resets
  if (feeStatus) feeStatus.textContent = '';
  if (quoteWarn) quoteWarn.textContent = '';
  if (downloadStatus) downloadStatus.textContent = '';
  if (tbody) tbody.innerHTML = '';
  if (table) table.classList.add('hidden');
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }
  if (zipBtn) zipBtn.disabled = true;

  walletAssetsAll = [];
  walletSelectedUnits = new Set();
  walletFilterState = {};

  backupsHasScan              = false;
  backupsLastPolicyId         = '';
  backupsLastRows             = [];
  backupsLastKeys             = [];
  backupsBaseAssets           = null;
  backupsCurrentAssetCount    = 0;
  backupsCurrentFeeAda        = 0;
  backupsCurrentFeeLovelace   = '0';

  const rawPolicy = (policyEl?.value || '').trim();

  if (!rawPolicy) {
    if (statusEl) statusEl.textContent = 'Enter a policy ID to scan.';
    return;
  }
  if (!meshWallet) {
    if (statusEl) statusEl.textContent = 'Connect your wallet in the gate first.';
    return;
  }
  if (!BLOCKFROST_PROJECT_ID) {
    if (statusEl) statusEl.textContent =
      'Blockfrost project ID is not set in the code. Please configure BLOCKFROST_PROJECT_ID.';
    return;
  }

  try {
    if (statusEl) {
      statusEl.textContent = 'Scanning your connected wallet for this policy‚Ä¶';
    }

    const allAssets = await meshWallet.getAssets();
    const matches = allAssets.filter(
      (a) => a && a.policyId === rawPolicy
    );

    if (!matches.length) {
      if (summary) {
        summary.innerHTML =
          `<span>Your wallet does not currently hold any assets under policy <code>${rawPolicy}</code>.</span>`;
      }
      if (walletSummaryEl) {
        walletSummaryEl.textContent =
          'No assets for this policy in your connected wallet.';
      }
      if (statusEl) statusEl.textContent = 'Wallet scan complete. No matching assets.';
      if (walletSection) walletSection.classList.remove('hidden');
      return;
    }

    if (walletSection) walletSection.classList.remove('hidden');

    const results = [];
    for (let i = 0; i < matches.length; i++) {
      const a = matches[i];
      if (statusEl) {
        statusEl.textContent =
          `Fetching metadata for wallet asset ${i + 1} / ${matches.length}‚Ä¶`;
      }

      const unit = a.unit || (a.policyId + (a.assetName || ''));
      if (!unit) continue;

      const metadata = await fetchMetadataForAsset(unit) || {};
      const policyHex = unit.slice(0, 56);
      const nameHex   = unit.slice(56);

      let assetName = '';
      if (typeof metadata.name === 'string' && metadata.name.trim()) {
        assetName = metadata.name.trim();
      } else {
        assetName = hexToAscii(nameHex) || '(no ASCII name)';
      }

      const quantity = String(a.quantity ?? '1');

      let imageUrl = '';
      let imgField = metadata.image;
      if (Array.isArray(imgField)) {
        imgField = imgField.find(v => typeof v === 'string') || null;
      }
      if (typeof imgField === 'string') {
        if (imgField.startsWith('ipfs://')) {
          let path = imgField.replace(/^ipfs:\/\//, '');
          if (path.startsWith('ipfs/')) {
            path = path.slice(5);
          }
          imageUrl = `https://ipfs.io/ipfs/${path}`;
        } else if (imgField.startsWith('http://') || imgField.startsWith('https://')) {
          imageUrl = imgField;
        }
      }

      results.push({
        unit,
        policyId: policyHex,
        nameHex,
        assetName,
        quantity,
        metadata,
        imageUrl,
      });
    }

    walletAssetsAll = results;
    backupsLastPolicyId = rawPolicy;

    // New: select all assets by default in wallet mode
    walletSelectedUnits = new Set(results.map(a => a.unit));

    if (summary) {
      summary.innerHTML =
        `<span>Your wallet holds <strong>${results.length}</strong> asset(s) under policy <code>${rawPolicy}</code>. Select the ones you want to BackUp below.</span>`;
    }

    buildWalletFiltersUI();
    renderWalletAssetsView();

    if (statusEl) {
      statusEl.textContent =
        'Wallet scan complete. Select assets to generate a BackUps quote.';
    }
  } catch (err) {
    console.error('[BackUps] wallet scan error:', err);
    if (statusEl) {
      statusEl.textContent =
        'An error occurred while scanning your wallet for this policy.';
    }
  }
}


function csvEscape(value) {
  const str = value == null ? '' : String(value);
  if (/[",\n\r]/.test(str)) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

// Normalize metadata values so hex-like strings become human-readable text or
// decoded CBOR objects, but keep structure (objects/arrays) and do NOT touch
// normal strings like URLs.
function normalizeMetadataValue(value) {
  // 0) Typed arrays (from CBOR) ‚Üí try to decode as UTF-8 text, else hex string
  if (
    value &&
    typeof value === 'object' &&
    (value instanceof Uint8Array ||
      (ArrayBuffer.isView(value) && !(value instanceof DataView)))
  ) {
    // Turn into a plain Uint8Array for safety
    const u8 = value instanceof Uint8Array ? value : new Uint8Array(value.buffer.slice(0));

    let asText = '';
    if (_utf8Decoder) {
      try {
        asText = _utf8Decoder.decode(u8);
        if (isPrintableAscii(asText)) {
          return asText;
        }
      } catch (e) {
        asText = '';
      }
    }

    // Fallback: hex string so it‚Äôs at least compact, not {0: 104, 1: 116, ‚Ä¶}
    let hex = '';
    for (let i = 0; i < u8.length; i++) {
      const h = u8[i].toString(16).padStart(2, '0');
      hex += h;
    }
    return hex;
  }

  // 1) Strings: only touch pure hex
  if (typeof value === 'string') {
    const isHex = /^[0-9a-fA-F]+$/.test(value) && value.length % 2 === 0;

    if (isHex) {
      // 1a) First try plain hex ‚Üí ASCII (for things like hex-encoded names)
      const ascii = hexToAscii(value);
      if (ascii && isPrintableAscii(ascii)) {
        // Printable ASCII only
        return ascii;
      }

      // 1b) If that fails, try CBOR decode (for nested JSON like socials)
      const cborVal = tryDecodeCborHex(value);
      if (cborVal !== null && cborVal !== undefined) {
        // Run normalization on the decoded structure too
        return normalizeMetadataValue(cborVal);
      }
    }

    // Non-hex or un-decodable hex ‚Äì leave as-is (URLs, normal text, etc.)
    return value;
  }

  // 2) Arrays: normalize elements recursively
  if (Array.isArray(value)) {
    return value.map(normalizeMetadataValue);
  }

  // 3) Objects: normalize each property recursively
  if (value && typeof value === 'object') {
    const out = {};

    for (const k in value) {
      if (!Object.prototype.hasOwnProperty.call(value, k)) continue;

      let newKey = k;

      // Special case: CBOR maps that encoded keys as "119,101,98,115,105,116,101"
      // ‚Üí interpret as ASCII codes if they look like that.
      if (/^\d+(,\d+)+$/.test(k)) {
        const codes = k.split(',').map((n) => parseInt(n, 10));
        if (codes.every((n) => Number.isFinite(n) && n >= 0 && n <= 255)) {
          const maybeStr = String.fromCharCode(...codes);
          if (isPrintableAscii(maybeStr)) {
            newKey = maybeStr;
          }
        }
      }

      out[newKey] = normalizeMetadataValue(value[k]);
    }

    return out;
  }

  // 4) Numbers, booleans, null, etc ‚Äì leave as-is
  return value;
}



function downloadReceiptForSearch(s) {
  if (!s || !s.paidTxHash) {
    alert('No recorded payment for this policy yet.');
    return;
  }

  const canvas = document.createElement('canvas');
  const width = 900;
  const height = 500;
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // Background
  ctx.fillStyle = '#050814';
  ctx.fillRect(0, 0, width, height);

  // Card
  ctx.fillStyle = '#0b1024';
  roundRect(ctx, 40, 40, width - 80, height - 80, 18);
  ctx.fill();

  ctx.strokeStyle = '#788dff';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Header
  ctx.fillStyle = '#e4e8ff';
  ctx.font = 'bold 28px "Segoe UI", sans-serif';
  ctx.fillText('BackUps Receipt', 70, 90);

  // Date/time
  const paidDate = s.paidAt ? new Date(s.paidAt) : new Date();
  ctx.font = '16px "Segoe UI", sans-serif';
  ctx.fillStyle = '#9aa3d9';
  ctx.fillText(paidDate.toLocaleString(), 70, 120);

  const lineYStart = 160;
  const baseLineH = 30;
  const labelX = 70;
  const valueX = 260;
  const maxValueWidth = width - valueX - 50;

  const rows = [
    ['Policy ID', s.policyId || '‚Äì'],
    ['Total assets (quoted)', s.assetCount != null ? String(s.assetCount) : '‚Äì'],
    ['Quoted fee', s.feeAda != null ? `${s.feeAda}‚Ç≥` : '‚Äì'],
    ['Paid fee', s.paidFeeAda != null ? `${s.paidFeeAda}‚Ç≥` : '‚Äì'],
    ['Buyer address', s.paidAddress || userAddress || '‚Äì'],
    ['Tx hash', s.paidTxHash || '‚Äì'],
  ];

  ctx.font = '16px "Segoe UI", sans-serif';

  let y = lineYStart;
  for (const [label, valueRaw] of rows) {
    const value = valueRaw || '‚Äì';

    ctx.fillStyle = '#9aa3d9';
    ctx.fillText(label + ':', labelX, y);

    ctx.fillStyle = '#e4e8ff';

    const lines = wrapText(ctx, value, maxValueWidth);
    lines.forEach((line, idx) => {
      ctx.fillText(line, valueX, y + idx * 18);
    });

    // advance by base line height + extra if wrapped
    y += baseLineH + Math.max(0, (lines.length - 1) * 18);
  }

  // Footer
  ctx.fillStyle = '#7cffb3';
  ctx.font = '14px "Segoe UI", sans-serif';
  ctx.fillText('BackUps by The Refresh', 70, height - 60);

  canvas.toBlob((blob) => {
    if (!blob) return;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const safePolicy = (s.policyId || 'policy').slice(0, 16);
    a.href = url;
    a.download = `BackUps_receipt_${safePolicy}.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 'image/png');
}

// Simple rounded rect helper
function roundRect(ctx, x, y, w, h, r) {
  const radius = typeof r === 'number'
    ? { tl: r, tr: r, br: r, bl: r }
    : { tl: 0, tr: 0, br: 0, bl: 0, ...r };

  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + w - radius.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + radius.tr);
  ctx.lineTo(x + w, y + h - radius.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - radius.br, y + h);
  ctx.lineTo(x + radius.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();
}

function wrapText(ctx, text, maxWidth) {
  const str = String(text || '');
  const lines = [];
  let line = '';

  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    const testLine = line + ch;
    const width = ctx.measureText(testLine).width;

    if (width > maxWidth && line) {
      lines.push(line);
      line = ch;
    } else {
      line = testLine;
    }
  }

  if (line) {
    lines.push(line);
  }

  return lines;
}



async function exportBackupsZip() {
  if (!backupsHasScan || !backupsLastRows.length || !window.JSZip || !window.saveAs) {
    return;
  }
  if (backupsRequiresPayment && !backupsIsHolder && !backupsPaidForCurrentPolicy) {
    alert('Complete payment for this policy before downloading the BackUps .zip.');
    return;
  }

  const downloadStatus = document.getElementById('backupsDownloadStatus');
  const zipBtn         = document.getElementById('backupsDownloadZipBtn');

  const headerLine = 'Processing BackUps request‚Ä¶ Fetching asset metadata and preparing ZIP‚Ä¶';

  if (zipBtn) {
    zipBtn.disabled = true;
  }
  if (downloadStatus) {
    // Make the processing text stand out more, with room under it for the counters
    downloadStatus.innerHTML =
      `<strong>${headerLine}</strong><br>` +
      `<span style="opacity:0.85;">Preparing metadata files‚Ä¶</span>`;
  }

  try {
    const zip    = new JSZip();
    const policy = backupsLastPolicyId || 'unknown_policy';
    const root   = zip.folder(`policy_${policy}`) || zip;

    // üîπ Pre-normalize metadata per row so hex-like strings become human-readable
    const normalizedRows = backupsLastRows.map((row) => {
      const rawMeta  = row.metadata || {};
      const normMeta = normalizeMetadataValue(rawMeta);
      return { row, meta: normMeta };
    });

    // 1) assets.json ‚Äì CIP-25 style for all assets (no "unit" field)
    const allCip25 = { "721": {} };

    for (const { row, meta } of normalizedRows) {
      const policyId = row.policyId;

      // assetName is guaranteed to be metadata.name from the scan
      const assetKey = row.assetName;
      if (!assetKey) continue; // safety guard

      if (!allCip25["721"][policyId]) {
        allCip25["721"][policyId] = {};
      }

      allCip25["721"][policyId][assetKey] = meta;
    }

    root.file('assets.json', JSON.stringify(allCip25, null, 2));

    // 2) metadata.csv ‚Äì spreadsheet with all metadata keys
    const keys    = backupsLastKeys;
    const headers = ['unit', 'assetName', 'quantity', ...keys];
    const lines   = [headers.map(csvEscape).join(',')];

    for (const { row, meta } of normalizedRows) {
      const vals = [
        row.unit,
        row.assetName,
        row.quantity,
        ...keys.map(k => {
          const v = meta[k];
          if (v === null || v === undefined) return '';
          if (typeof v === 'object') return JSON.stringify(v);
          return String(v);
        }),
      ];
      lines.push(vals.map(csvEscape).join(','));
    }

    const csvString = lines.join('\n');
    root.file('metadata.csv', csvString);

    // 3) by_asset/*.json ‚Äì one CIP-25 style JSON per asset
    const perAsset = root.folder('by_asset');

    for (const { row, meta } of normalizedRows) {
      const assetKey = row.assetName;
      if (!assetKey) continue; // extra safety

      const cip25 = {
        "721": {
          [row.policyId]: {
            [assetKey]: meta
          }
        }
      };

      // file name based on the asset name, cleaned up
      let safeName = assetKey.trim();
      if (!safeName) continue;

      // Replace anything not A‚ÄìZ, 0‚Äì9, _ or - with "_"
      safeName = safeName.replace(/[^a-z0-9_\-]/gi, '_');

      perAsset.file(
        `${safeName}.json`,
        JSON.stringify(cip25, null, 2)
      );
    }

    // 4) images/ ‚Äì download image files from IPFS / HTTP where possible
    const imgFolder = root.folder('images');

    // First, collect all image tasks (so we know how many there are)
    const imageTasks = [];

    for (const { row, meta } of normalizedRows) {
      let imgField = meta.image;
      if (!imgField) continue;

      // Some collections use an array of images ‚Äì grab the first string
      if (Array.isArray(imgField)) {
        imgField = imgField.find(v => typeof v === 'string') || null;
      }
      if (typeof imgField !== 'string') continue;

      let finalUrl = null;

      if (imgField.startsWith('ipfs://')) {
        // ipfs://Qm... or ipfs://ipfs/Qm...
        let path = imgField.replace(/^ipfs:\/\//, '');
        if (path.startsWith('ipfs/')) {
          path = path.slice(5);
        }
        // You can swap to your preferred gateway here
        finalUrl = `https://ipfs.io/ipfs/${path}`;
      } else if (imgField.startsWith('https://') || imgField.startsWith('http://')) {
        finalUrl = imgField;
      } else {
        // Unknown scheme (e.g. bare CID) ‚Äì skip for now
        continue;
      }

  if (!finalUrl) continue;

  // Use the asset name for the image filename, sanitized.
  // Fall back to unit only if there is no assetName at all.
  let safeName = (row.assetName && row.assetName.trim())
    ? row.assetName.trim()
    : row.unit;

  // Replace any character that isn't A‚ÄìZ, 0‚Äì9, _ or - with "_"
  safeName = safeName.replace(/[^a-z0-9_\-]/gi, '_');

  imageTasks.push({ finalUrl, safeName, expectedBytes: null });

    }

    const totalImages = imageTasks.length;
    let completedImages = 0;
    let successfulImages = 0;
    let totalBytesExpected = 0;
    let totalBytesReceived = 0;

    function updateDownloadProgress() {
      if (!downloadStatus) return;

      const mb = (bytes) => (bytes / (1024 * 1024)).toFixed(2);

      let bytesLine = '';
      if (totalImages > 0) {
        if (totalBytesExpected > 0) {
          bytesLine =
            `Downloading images ${completedImages} / ${totalImages} ` +
            `‚Äì ${mb(totalBytesReceived)} / ${mb(totalBytesExpected)} MB`;
        } else {
          bytesLine =
            `Downloading images ${completedImages} / ${totalImages} ` +
            `‚Äì ${mb(totalBytesReceived)} MB so far`;
        }
      }

      const extraHint =
        `<span style="opacity:0.8;">` +
        `This can take a while for large collections. ` +
        `Please keep this tab open until it says the ZIP is ready.` +
        `</span>`;

      if (bytesLine) {
        downloadStatus.innerHTML =
          `<strong>${headerLine}</strong><br>` +
          `${bytesLine}<br>` +
          extraHint;
      } else {
        // No images ‚Äì just show the header & hint
        downloadStatus.innerHTML =
          `<strong>${headerLine}</strong><br>` +
          `<span style="opacity:0.85;">Preparing metadata files‚Ä¶</span><br>` +
          extraHint;
      }
    }

    // Initial state
    if (totalImages > 0) {
      updateDownloadProgress();
    } else if (downloadStatus) {
      downloadStatus.innerHTML =
        `<strong>${headerLine}</strong><br>` +
        `<span style="opacity:0.85;">No image URLs found; preparing metadata-only ZIP‚Ä¶</span>`;
    }

    function isRetryableStatus(status) {
      // 504 is the main one you‚Äôre seeing; also treat common transient codes as retryable
      return (
        status === 408 || // Request Timeout
        status === 429 || // Too Many Requests / rate limiting
        status === 500 ||
        status === 502 ||
        status === 503 ||
        status === 504
      );
    }

    async function fetchImageOnce(task, attempt, maxAttempts) {
      const { finalUrl, safeName } = task;

      try {
        const res = await fetch(finalUrl);
        if (!res.ok) {
          console.warn(
            `[BackUps] Image fetch failed (attempt ${attempt}/${maxAttempts}) for`,
            finalUrl,
            res.status
          );

          // For non-retryable status, stop immediately; for retryable ones, let caller retry
          if (isRetryableStatus(res.status)) {
            return 'retry';
          }
          return 'non-retryable';
        }

        const contentType = res.headers.get('content-type') || '';
        let ext = 'bin';

        if (contentType.includes('png')) ext = 'png';
        else if (contentType.includes('jpeg') || contentType.includes('jpg')) ext = 'jpg';
        else if (contentType.includes('gif')) ext = 'gif';
        else if (contentType.includes('webp')) ext = 'webp';
        else {
          // Try to guess from URL path
          try {
            const urlObj = new URL(finalUrl);
            const path   = urlObj.pathname.toLowerCase();
            if (path.endsWith('.png')) ext = 'png';
            else if (path.endsWith('.jpg') || path.endsWith('.jpeg')) ext = 'jpg';
            else if (path.endsWith('.gif')) ext = 'gif';
            else if (path.endsWith('.webp')) ext = 'webp';
          } catch (_) { /* ignore URL parse issues */ }
        }

        // Track bytes using streaming reader if available
        const contentLengthHeader = res.headers.get('content-length');
        if (contentLengthHeader && task.expectedBytes == null) {
          const parsed = parseInt(contentLengthHeader, 10);
          if (!Number.isNaN(parsed) && parsed > 0) {
            task.expectedBytes = parsed;
            totalBytesExpected += parsed;
          }
        }

        let arrayBuffer;
        if (res.body && res.body.getReader) {
          const reader = res.body.getReader();
          const chunks = [];
          let receivedForThis = 0;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            receivedForThis += value.byteLength;
            totalBytesReceived += value.byteLength;
            updateDownloadProgress();
          }

          const totalLength = chunks.reduce((sum, c) => sum + c.byteLength, 0);
          const merged = new Uint8Array(totalLength);
          let offset = 0;
          for (const c of chunks) {
            merged.set(c, offset);
            offset += c.byteLength;
          }
          arrayBuffer = merged.buffer;
        } else {
          // Fallback for browsers without streaming support
          arrayBuffer = await res.arrayBuffer();
          totalBytesReceived += arrayBuffer.byteLength;
          updateDownloadProgress();
        }

        imgFolder.file(`${safeName}.${ext}`, arrayBuffer);
        return 'success';
      } catch (err) {
        console.warn(
          `[BackUps] Image fetch error (attempt ${attempt}/${maxAttempts}) for`,
          finalUrl,
          err
        );
        // Network errors are typically retryable
        return 'retry';
      }
    }

    async function fetchImageWithRetries(task, maxAttempts = 10) {
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const result = await fetchImageOnce(task, attempt, maxAttempts);
        if (result === 'success') {
          successfulImages++;
          return;
        }
        if (result === 'non-retryable') {
          // Don‚Äôt hammer a clearly broken URL
          console.warn('[BackUps] Non-retryable failure; skipping image:', task.finalUrl);
          return;
        }
        // result === 'retry'
        // Small exponential-ish backoff before next attempt
        await new Promise(r => setTimeout(r, 1000 * attempt));
      }

      console.warn(
        `[BackUps] Giving up after multiple attempts for image:`,
        task.finalUrl
      );
    }

    const imageFetchPromises = [];

    for (const task of imageTasks) {
      imageFetchPromises.push(
        (async () => {
          await fetchImageWithRetries(task);
          // Mark this image as "done" (either saved or finally failed)
          completedImages++;
          updateDownloadProgress();
        })()
      );
    }

    // Wait for all image downloads (with retries) to finish before finalizing ZIP
    if (imageFetchPromises.length) {
      await Promise.all(imageFetchPromises);
    }

    if (downloadStatus) {
      if (successfulImages === totalImages) {
        downloadStatus.innerHTML =
          `<strong>Image downloads complete.</strong><br>` +
          `<span style="opacity:0.9;">Finalizing BackUps .zip‚Ä¶</span>`;
      } else {
        const missing = totalImages - successfulImages;
        downloadStatus.innerHTML =
          `<strong>Image download attempts finished.</strong><br>` +
          `<span style="opacity:0.9;">Finalizing BackUps .zip‚Ä¶</span><br>` +
          `<span style="color:#ff8b94;">${missing} image(s) could not be fetched after several retries ` +
          `(gateway timeouts or missing files). All successfully downloaded images are included.</span>`;
      }
    }

    // 5) README.txt
    const readme = [
      'BackUps by The Refresh',
      '-----------------------',
      '',
      `Policy ID: ${policy}`,
      '',
      'Contents:',
      '- assets.json       : All assets under the policy, including metadata per asset.',
      '- metadata.csv      : Spreadsheet-friendly view of all on-chain metadata properties.',
      '- by_asset/*.json   : One CIP-25 721-style JSON file per asset.',
      '- images/*          : Image files fetched from IPFS / HTTPS image URLs where available.',
      '',
      'Generated for backup / analysis. No private keys were used or exposed.',
    ].join('\n');
    root.file('README.txt', readme);

    const blob     = await zip.generateAsync({ type: 'blob' });
    const filename = `BackUps_${policy}.zip`;

    if (downloadStatus) {
      if (successfulImages === totalImages) {
        downloadStatus.innerHTML =
          `<strong>Processing complete!</strong> Your BackUps .zip is ready to save.`;
      } else {
        const missing = totalImages - successfulImages;
        downloadStatus.innerHTML =
          `<strong>Processing complete!</strong> Your BackUps .zip is ready to save.<br>` +
          `<span style="color:#ff8b94;">Note: ${missing} image(s) could not be fetched ` +
          `after multiple retries and are not included in this ZIP.</span>`;
      }
    }

    saveAs(blob, filename);
  } catch (err) {
    console.error('[BackUps] exportBackupsZip error:', err);
    if (downloadStatus) {
      downloadStatus.textContent =
        'An error occurred while preparing the BackUps .zip. Please try again.';
    }
  } finally {
    if (zipBtn) {
      zipBtn.disabled = false;
    }
  }
}




async function payForCurrentPolicy() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }
  if (!backupsRequiresPayment || backupsIsHolder) {
    // Nothing to do here; holders don‚Äôt pay in this flow
    return;
  }
if (!backupsLastPolicyId || backupsCurrentFeeAda <= 0) {
  alert('Scan a policy with assets before paying.');
  return;
}


  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const scanStatus = document.getElementById('backupsScanStatus');

  try {
    if (feeStatus) {
      feeStatus.textContent =
        `Building ${backupsCurrentFeeAda}‚Ç≥ BackUps transaction for policy ${backupsLastPolicyId}‚Ä¶`;
    }
    if (payBtn) {
      payBtn.disabled = true;
      payBtn.textContent = 'Waiting for wallet‚Ä¶';
    }
    if (zipBtn) zipBtn.disabled = true;

    const tx = new Transaction({ initiator: meshWallet });

    const lovelace = String(backupsCurrentFeeAda * 1_000_000);
    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, lovelace);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Policy payment tx hash:', txHash);

    backupsPaidForCurrentPolicy = true;

    if (feeStatus) {
      feeStatus.textContent =
        `Payment submitted for policy ${backupsLastPolicyId}.\n` +
        `Tx: ${txHash}`;
    }

    if (backupsMode === 'blockchain') {
      // Existing behavior: run a full metadata scan after payment
      if (feeStatus) {
        feeStatus.textContent += '\nFetching asset metadata and preparing ZIP‚Ä¶';
      }

      if (scanStatus) {
        scanStatus.textContent = 'Scanning assets and fetching on-chain metadata‚Ä¶';
      }

      const downloadStatus = document.getElementById('backupsDownloadStatus');
      if (downloadStatus) {
        const headerLine =
          'Processing BackUps request‚Ä¶ Fetching asset metadata and preparing ZIP‚Ä¶';
        downloadStatus.innerHTML =
          `<strong>${headerLine}</strong><br>` +
          `<span style="opacity:0.85;">Preparing metadata files‚Ä¶</span>`;
      }

      await scanMetadataForCurrentPolicy(
        document.getElementById('backupsDownloadStatus') ||
        scanStatus ||
        feeStatus ||
        null
      );

      if (scanStatus) {
        scanStatus.textContent = 'Scan complete.';
      }
    } else {
      // Wallet mode: metadata is already loaded for the selected assets
      if (scanStatus) {
        scanStatus.textContent =
          'Wallet selection confirmed. You can now download the BackUps .zip for these assets.';
      }
      // Ensure Results & export panel is up to date
      renderBackupsResults();
    }


    // renderBackupsResults() was called inside scanMetadataForCurrentPolicy,
    // so at this point ZIP is unlocked for this policy.
    
        // üîπ Save/update previous search with receipt info for this policy
    await savePreviousSearch(
      backupsLastPolicyId,
      backupsCurrentAssetCount,
      backupsCurrentFeeAda,
      {
        paidFeeAda: backupsCurrentFeeAda,
        paidAt: Date.now(),
        paidTxHash: txHash,
        paidAddress: userAddress || null,
      }
    );


  } catch (err) {
    console.error('[BackUps] payForCurrentPolicy error:', err);
    if (feeStatus) {
      feeStatus.textContent =
        'Payment failed or was rejected. No funds were taken. You can try again.';
    }
  } finally {
    if (payBtn) {
      payBtn.disabled = false;
      payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
    }
  }
}


// ---------------------------------------------------------
// Initialize BackUps app after gate
// (keeping initLocApp name so gate flow stays simple)
// ---------------------------------------------------------
let backupsInitialized = false;
async function initLocApp(accessVia) {
  if (backupsInitialized) return;
  backupsInitialized = true;

  const walletShortEl = document.getElementById('backupsWalletShort');
  const accessTypeEl  = document.getElementById('backupsAccessType');

  if (!meshWallet) return;
  if (!userAddress) {
    userAddress = await meshWallet.getChangeAddress();
  }

  if (walletShortEl) walletShortEl.textContent = shortenAddress(userAddress);

if (accessTypeEl) {
  if (accessVia === 'holder') {
    accessTypeEl.textContent = 'VIP access via The Refresh Whale status.';
  } else {
    accessTypeEl.textContent = 'Per-policy BackUps pricing (non-whale).';
  }
}
backupsIsHolder = (accessVia === 'holder');
backupsRequiresPayment = !backupsIsHolder;
  
// Wire BackUps buttons
const scanBtn = document.getElementById('backupsScanBtn');
const zipBtn  = document.getElementById('backupsDownloadZipBtn');
const payBtn  = document.getElementById('backupsPayBtn');

if (scanBtn) {
  scanBtn.addEventListener('click', () => {
    if (backupsMode === 'wallet') {
      backupsScanWalletPolicy();
    } else {
      backupsScanForPolicy();
    }
  });
}
zipBtn?.addEventListener('click', exportBackupsZip);
payBtn?.addEventListener('click', payForCurrentPolicy);

  // Mode toggle: Blockchain vs Connected Wallet
  const modeRadios = document.querySelectorAll('input[name="backupsMode"]');
  modeRadios.forEach((radio) => {
    radio.addEventListener('change', (evt) => {
      setBackupsMode(evt.target.value);
    });
  });
  // Set initial mode
  setBackupsMode('blockchain');

  // Wallet filter buttons
  const applyFiltersBtn = document.getElementById('walletApplyFiltersBtn');
  const clearFiltersBtn = document.getElementById('walletClearFiltersBtn');

  applyFiltersBtn?.addEventListener('click', () => {
    walletFilterState = {};
    const container = document.getElementById('walletFiltersContainer');
    if (!container) return;
    const checkboxes = container.querySelectorAll(
      'input[type="checkbox"][data-key][data-value]'
    );
    checkboxes.forEach((cb) => {
      if (!cb.checked) return;
      const key = cb.dataset.key;
      const val = cb.dataset.value;
      if (!walletFilterState[key]) {
        walletFilterState[key] = new Set();
      }
      walletFilterState[key].add(val);
    });
    renderWalletAssetsView();
  });

  clearFiltersBtn?.addEventListener('click', () => {
    walletFilterState = {};
    const container = document.getElementById('walletFiltersContainer');
    if (container) {
      const checkboxes = container.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((cb) => { cb.checked = false; });
    }
    renderWalletAssetsView();
  });

  // New: "Select all" checkbox in the filter header
  const selectAllCheckbox = document.getElementById('walletSelectAllCheckbox');
  const selectAllLabel = document.querySelector('.wallet-select-all');

  // Clicking the label shouldn't toggle the <details> open/close
  selectAllLabel?.addEventListener('click', (evt) => {
    evt.stopPropagation();
  });

  // When the checkbox changes, select or deselect all wallet assets
  selectAllCheckbox?.addEventListener('change', () => {
    if (!walletAssetsAll.length) return;

    walletSelectedUnits = new Set();
    if (selectAllCheckbox.checked) {
      walletAssetsAll.forEach(a => walletSelectedUnits.add(a.unit));
    }
    renderWalletAssetsView();
  });

  
// Assets modal open/close
  const assetsModal        = document.getElementById('backupsAssetsModal');
  const assetsModalOpenBtn = document.getElementById('backupsOpenAssetsModalBtn');
  const assetsModalCloseBtn = document.getElementById('backupsAssetsModalClose');

  if (assetsModal && assetsModalOpenBtn) {
    assetsModalOpenBtn.addEventListener('click', () => {
      assetsModal.classList.remove('hidden');
    });

    // Click on backdrop closes the modal
    assetsModal.addEventListener('click', (evt) => {
      if (evt.target === assetsModal) {
        assetsModal.classList.add('hidden');
      }
    });

    assetsModalCloseBtn?.addEventListener('click', () => {
      assetsModal.classList.add('hidden');
    });
  }

  // Render any previously loaded searches into the UI
  renderPreviousSearches();
  
  const policyInput = document.getElementById('backupsPolicyInput');

  function handlePolicyInputChange() {
    if (!policyInput || !scanBtn) return;

    const val = policyInput.value.trim();
    if (!val) {
      scanBtn.disabled = false;
      return;
    }

    // Previous-quote / one-scan behavior only applies to full blockchain mode.
    if (backupsMode !== 'blockchain') {
      scanBtn.disabled = false;
      return;
    }

    const existing = backupsPreviousSearches.find(
      (s) => s.policyId === val
    );

    if (existing) {
      runQuotedScanFlow(existing);
      scanBtn.disabled = true;
    } else {
      scanBtn.disabled = false;
    }
  }


  policyInput?.addEventListener('input', handlePolicyInputChange);
  policyInput?.addEventListener('blur', handlePolicyInputChange);

  // Click-to-paste policy ID from clipboard
  if (policyInput && navigator.clipboard && navigator.clipboard.readText) {
    policyInput.addEventListener('click', async () => {
      try {
        const text = await navigator.clipboard.readText();
        if (!text) return; // nothing on clipboard
        policyInput.value = text.trim();
        handlePolicyInputChange(); // re-run quote / one-scan logic
      } catch (err) {
        console.warn('[BackUps] clipboard paste failed:', err);
        // fail silently: user can still paste manually
      }
    });
  }

} // end of initLocApp


async function checkPolicyAssets() {
  if (!meshWallet) return;

  walletStatus.classList.remove('hidden');
  walletStatus.textContent = 'Checking Wallet‚Ä¶';
  accessMessage.textContent = '';
  accessMessage.classList.remove('error');

  try {
    const assets = await meshWallet.getAssets();
    console.log('[BackUps Gate] Assets:', assets);

    const required = Object.create(null);
    for (const p of ACCESS_POLICIES) required[p.policyId] = 0;

    for (const asset of assets) {
      if (asset && required[asset.policyId] !== undefined) {
        required[asset.policyId]++;
      }
    }

    const unmet = ACCESS_POLICIES.filter(
      p => (required[p.policyId] || 0) < p.minAssets
    );

    if (unmet.length === 0) {
      // Holder: free access
      backupsIsHolder = true;
      backupsRequiresPayment = false;

      const detail = buildRequirementsDetail(required);

      walletStatus.textContent =
        `‚úÖ Access granted.\n${detail}`;

      accessMessage.classList.remove('error');
      accessMessage.innerHTML = `<strong>Access granted. Loading BackUps‚Ä¶</strong>`;

      payAccessBtn.style.display = 'none';

      protectedArea.classList.remove('hidden');
      gateOverlay.classList.add('hidden');
      initLocApp('holder');
    } else {
      // Non-holder: per-policy pricing mode
      backupsIsHolder = false;
      backupsRequiresPayment = true;

      const detail = buildRequirementsDetail(required);
      walletStatus.textContent = detail;

      accessMessage.classList.add('error');
      accessMessage.innerHTML =
        `You don‚Äôt yet meet the VIP BackUps access requirements.<br>` +
        `Press ‚ÄúEnter BackUps‚Äù below to continue and scan a policy with per-policy pricing.`;


      payAccessBtn.textContent = 'Enter BackUps';
      payAccessBtn.style.display = 'inline-flex';

      // Clicking this just opens BackUps in non-holder mode
      payAccessBtn.onclick = () => {
        protectedArea.classList.remove('hidden');
        gateOverlay.classList.add('hidden');
        initLocApp('nonholder');
      };
    }

  } catch (err) {
    console.error(err);
    walletStatus.textContent = 'Error checking wallet assets.';
    accessMessage.classList.add('error');
    accessMessage.textContent = 'An error occurred while checking your wallet. Please try again.';
  }
}

// ---------------------------------------------------------
// Pay 5‚Ç≥ for 30 days BackUps access
// ---------------------------------------------------------
async function payForLocAccess() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }

  if (!GATE_RECIPIENT_ADDRESS) {
    alert('Gate recipient address is not configured yet.\n\nPlease set GATE_RECIPIENT_ADDRESS in the code.');
    return;
  }

  try {
    payAccessBtn.disabled = true;
    payAccessBtn.textContent = 'Preparing payment‚Ä¶';
    accessMessage.classList.remove('error');
    accessMessage.textContent = `Building ${ACCESS_PASS_FEE_ADA}‚Ç≥ BackUps access transaction‚Ä¶`;

    const tx = new Transaction({ initiator: meshWallet });

    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, ACCESS_PASS_FEE_LOVELACE);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Access payment tx hash:', txHash);

    await logPaidAccess(txHash);

    walletStatus.textContent = `BackUps access paid. Tx: ${txHash}`;
    accessMessage.classList.remove('error');
    accessMessage.innerHTML = `<strong>Access granted. Welcome to BackUps.</strong>`;

    locPassDaysLeft = 30;

    protectedArea.classList.remove('hidden');
    gateOverlay.classList.add('hidden');
    initLocApp('pass');

  } catch (err) {
    console.error('[BackUps] payForLocAccess error:', err);
    accessMessage.classList.add('error');
    accessMessage.textContent =
      'Payment failed or was rejected. No funds were taken. You can try again.';
  } finally {
    payAccessBtn.disabled = false;
    payAccessBtn.textContent = `Pay ${ACCESS_PASS_FEE_ADA}‚Ç≥ for 30 days access`;
  }
}

// ---------------------------------------------------------
// Connect wallet via Mesh
// ---------------------------------------------------------
async function connect() {
  const walletId = sel.value;
  if (!walletId) {
    alert('Select a wallet');
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Connecting‚Ä¶';

  try {
    meshWallet  = await BrowserWallet.enable(walletId);
    userAddress = await meshWallet.getChangeAddress();

    // Try reward (stake) address as identity, fallback to payment address
    try {
      const rewardAddrs = await meshWallet.getRewardAddresses?.();
      if (Array.isArray(rewardAddrs) && rewardAddrs.length > 0) {
        userIdentity = rewardAddrs[0];
      } else {
        userIdentity = userAddress;
      }
    } catch (e) {
      console.warn('[BackUps] getRewardAddresses not available, using payment address as identity.');
      userIdentity = userAddress;
    }

    // Load any previous searches for this identity (if any)
    await loadPreviousSearches();

    btn.textContent = `Connected: ${walletId}`;
    sel.disabled = true;

    await checkPolicyAssets();


  } catch (e) {
    console.error('Wallet connection failed:', e);

    let humanMsg =
      'Connection failed.\n\n' +
      '‚Ä¢ If your wallet uses a PIN/password, open the wallet extension/app and unlock it first.\n' +
      '‚Ä¢ Then come back here and press "Connect Wallet" again.';

    if (e && e.message) {
      humanMsg = `Connection failed: ${e.message}\n\n` + humanMsg;
    }

    alert(humanMsg);
    btn.textContent = 'Connect Wallet';
    btn.disabled = false;
  }
}

document.addEventListener('DOMContentLoaded', detect);
btn.addEventListener('click', connect);
</script>

</body>
</html>

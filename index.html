<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BackUps by The Refresh</title>
  <style>
    :root {
      --gap: 1rem;
      --pad: .5rem;
      --primary: #2196F3;
      --primary-dark: #1976D2;
      --secondary: #21CBF3;
      --text: #e4e8ff;
      --text-light: #9aa3d9;
      --bg: #050810;
      --card-bg: rgba(7, 12, 30, 0.92);
      --border: rgba(120, 141, 255, 0.35);
      --success: #4CAF50;
      --error: #f44336;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #000;
      color: var(--text);
      line-height: 1.6;
    }

    /* --- WALLET GATE OVERLAY --- */
    #gateOverlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 10;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      background: radial-gradient(circle at top left, #202738 0, #050810 55%, #020308 100%);
      color: #e4e8ff;
    }

    header {
      position: relative;
      background: transparent;
      color: white;
      text-align: center;
      padding: 2rem var(--pad) 1.5rem;
      box-shadow: none;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    #description {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 1.5rem;
    }

    #instructions {
      font-size: 1rem;
      margin: 1rem 0;
      color: #a9b5ff;
    }

    #walletStatus {
      background: rgba(9, 16, 40, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(106, 255, 183, 0.4);
      color: #a7ffcb;
      padding: 0.5rem 1.5rem;
      display: inline-block;
      margin-top: 1rem;
      font-weight: 500;
      backdrop-filter: blur(5px);
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 0 var(--pad);
    }

    .card {
      background: rgba(5, 10, 24, 0.9);
      border-radius: 18px;
      border: 1px solid rgba(120, 141, 255, 0.25);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      color: #e4e8ff;
      backdrop-filter: blur(10px);
      padding: 2rem;
      margin: 2rem auto;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    #connectBtn {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #connectBtn:hover {
      background: linear-gradient(135deg, #ff4b80, #ffd46b);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.7);
    }

    #connectBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    #payAccessBtn {
      margin-top: 0.75rem;
      background: linear-gradient(135deg, #21cbf3, #7cffb3);
      color: #050814;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #payAccessBtn:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
    }

    select, input {
      padding: 0.8rem;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 1rem;
      width: 100%;
      background: rgba(3, 7, 20, 0.9);
      border-color: rgba(96, 125, 255, 0.6);
      color: #e4e8ff;
    }

    .hidden { display: none !important; }

    .access-message {
      margin-top: 1rem;
      font-size: 1rem;
      color: #b7c3ff;
      white-space: pre-line;
    }

    .access-message strong { color: var(--success); }
    .access-message.error { color: #ff8b94; }

    .access-message a {
      color: #ffc857;
      text-decoration: underline;
    }

    header .container {
      max-width: 860px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .brand-logo {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      width: 52px;
      height: auto;
      padding: 0.25rem;
      background: rgba(5, 8, 16, 0.9);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
    }

    header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.04em;
    }

    /* Gated area layout */
    .loc-container {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      max-width: 720px;
      margin: 0 auto;
      padding: 1.5rem 1.75rem;
    }

    .loc-header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .loc-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
    }

    .loc-title-accent {
      opacity: 0.8;
      font-size: 0.95em;
    }

    .loc-subtitle {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .loc-status-block {
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(6px);
    }

    .loc-status {
      margin: 0;
      font-size: 0.95rem;
    }

    .loc-status-ok {
      font-weight: 500;
    }

    .loc-main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 1.25rem;
      width: 100%;
    }

    .loc-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .loc-card {
      background: rgba(5, 12, 28, 0.95);
      border-radius: 0.9rem;
      border: 1px solid rgba(120, 141, 255, 0.2);
      padding: 1rem 1.1rem;
      font-size: 0.9rem;
    }

    .loc-card h3 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1rem;
    }

    .loc-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 0.75rem;
      font-size: 0.85rem;
    }

    .loc-field span {
      opacity: 0.85;
    }

    .loc-field input {
      border-radius: 0.6rem;
      padding: 0.55rem 0.7rem;
    }

    .loc-btn-primary,
    .loc-btn-secondary {
      border-radius: 999px;
      padding: 0.55rem 1rem;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    .loc-btn-primary {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 20px rgba(0,0,0,0.7);
      margin-top: 0.25rem;
    }

    .loc-btn-primary:hover {
      transform: translateY(-1px) scale(1.01);
    }

    .loc-btn-secondary {
      background: rgba(10, 18, 46, 0.9);
      color: #e4e8ff;
      border: 1px solid rgba(120, 141, 255, 0.6);
    }

    .loc-hint {
      font-size: 0.75rem;
      opacity: 0.75;
    }

    .loc-tx-status {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .table-wrapper {
      max-height: 260px;
      overflow: auto;
      margin-top: 0.5rem;
    }

    .loc-results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    .loc-results-table th,
    .loc-results-table td {
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 0.35rem 0.5rem;
      text-align: left;
      word-break: break-all;
    }

    .loc-results-table th {
      background: rgba(10, 18, 46, 0.9);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    @media (max-width: 800px) {
      .loc-main {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    @media (max-width: 600px) {
      header .container { padding-top: 1.5rem; }
      header h1 { font-size: 1.9rem; }
      .card { margin-top: 1.5rem; padding: 1.5rem; }
      .row { flex-direction: column; align-items: stretch; }
    }
  </style>
</head>
<body>

<!-- Gated area wrapper (shown only after access granted) -->
<div id="protectedArea" class="hidden">
  <div id="backupsContainer" class="loc-container">
    <header class="loc-header">
      <h2 class="loc-title">
        BackUps <span class="loc-title-accent">by The Refresh</span>
      </h2>
      <p class="loc-subtitle">
        One-click backup of all assets under a policy ID. No wallet scan, chain-wide view.
      </p>
    </header>

    <section class="loc-status-block">
      <p class="loc-status loc-status-ok">
        Connected wallet: <span id="backupsWalletShort">‚Äì</span><br/>
        Access type: <span id="backupsAccessType">‚Äì</span>
      </p>
    </section>

    <section class="loc-main">
      <!-- LEFT: controls -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Scan a policy</h3>

          <label class="loc-field">
            <span>Policy ID to backup</span>
            <input id="backupsPolicyInput"
                   type="text"
                   placeholder="Paste a 56-character policy ID (no spaces)"/>
          </label>

          <button type="button" id="backupsScanBtn" class="loc-btn-primary">
            Scan policy on chain
          </button>

          <p class="loc-hint">
            BackUps queries Blockfrost for all assets under this policy and grabs every
            on-chain metadata property it finds. No wallet contents are scanned for this step.
          </p>

          <p id="backupsScanStatus" class="loc-tx-status"></p>
        </div>
      </div>

      <!-- RIGHT: results + ZIP export -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Results & export</h3>
          <div id="backupsResultsSummary" class="loc-field">
            <span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>
          </div>

<div class="table-wrapper">
  <table id="backupsResultsTable" class="loc-results-table hidden">
    <thead>
      <tr>
        <th>Asset Name (ASCII)</th>
        <th>Quantity</th>
        <th>Full Unit</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<p id="backupsFeeStatus" class="loc-tx-status"></p>

<div style="display:flex; flex-wrap:wrap; gap:0.5rem; margin-top:0.75rem;">
  <button type="button"
          id="backupsPayBtn"
          class="loc-btn-secondary"
          style="display:none;">
    <!-- label is set in JS -->
    Pay &amp; unlock ZIP
  </button>

  <button type="button"
          id="backupsDownloadZipBtn"
          class="loc-btn-secondary"
          disabled>
    Download BackUps .zip
  </button>
</div>

        </div>
      </div>
    </section>
  </div>
</div>

<!-- WALLET GATE OVERLAY -->
<div id="gateOverlay">
  <img src="RF5.png" alt="Fre5h Logo" class="brand-logo">

  <header>
    <div class="container">
      <h1>BackUps Access</h1>

      <p id="description">BackUps is free for The Refresh Whales. Others pay 100‚Ç≥ per 1000 assets per policy BackUp.</p>

      <p id="instructions"></p>

      <div class="row" id="connectRow">
        <select id="walletSelect">
          <option value="">Select Wallet‚Ä¶</option>
        </select>
        <button id="connectBtn" disabled>Connect Wallet</button>
      </div>

      <div id="walletStatus" class="hidden"></div>
    </div>
  </header>

  <div class="container">
    <div class="card">
      <h2>Access Gate</h2>
<p class="access-message">
  The Refresh Whales get in VIP. Pricing for others is 100‚Ç≥ per 1000 assets (per policy BackUp).
</p>


      <p id="gateBlurb"></p>
      <p id="accessMessage" class="access-message"></p>

      <!-- Shown only if policy requirements are NOT met -->
<button id="payAccessBtn" style="display:none;">
  Enter BackUps
</button>

    </div>
  </div>
</div>


<!-- JSZip + FileSaver for ZIP export (no integrity to avoid mismatch blocking) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"
        referrerpolicy="no-referrer"></script>


<script type="module">
import {
  BrowserWallet,
  Transaction,
} from 'https://esm.sh/@meshsdk/core@1.9.0-beta.62?bundle';

const sel           = document.getElementById('walletSelect');
const btn           = document.getElementById('connectBtn');
const walletStatus  = document.getElementById('walletStatus');
const accessMessage = document.getElementById('accessMessage');
const gateOverlay   = document.getElementById('gateOverlay');
const protectedArea = document.getElementById('protectedArea');

const instructionsEl = document.getElementById('instructions');
const gateBlurbEl    = document.getElementById('gateBlurb');
const payAccessBtn   = document.getElementById('payAccessBtn');

// TODO: replace with your real receive address (no extra text)
const GATE_RECIPIENT_ADDRESS =
  'addr1q9m2reerla2ccrkwz57rhwl7q8vj8y38x39nv4mq56ppjqmzs7jlke6nm3thlvvddtsnp52s62u0337y9h6d2gmma2wsmjx8nh';

// =========================================================
// Pricing / Fees
// 100‚Ç≥ per 1000 assets (per policy BackUp) for non-holders
// =========================================================
const ACCESS_FEE_PER_1000_ADA = 100;

function computeBackupsFeeAda(assetCount) {
  if (!assetCount || assetCount <= 0) return 0;
  const blocks = Math.ceil(assetCount / 1000);
  return blocks * ACCESS_FEE_PER_1000_ADA;
}


// =========================================================
// Blockfrost config for BackUps (policy-based scan)
// =========================================================
const BLOCKFROST_ENDPOINT   = 'https://cardano-mainnet.blockfrost.io/api/v0';
// üîê IMPORTANT: put your mainnet Blockfrost project key here:
const BLOCKFROST_PROJECT_ID = 'mainnetehvvvJVoJUAz5DFJJz2L9fHZmkXlXTMP'; // e.g. 'mainnetXXXXX...'

// =========================================================
// Fre5h / The Refresh holder access requirements
// =========================================================
const ACCESS_POLICIES = [
  {
    policyId: 'adc5716393953403109c335e68c0384238fd19653e960e03afa1fb1f',
    minAssets: 25,
    label: 'OG The Refresh',
    purchaseUrl: 'https://www.jpg.store/collection/therefresh'
  }
];

// mesh / identity state
let meshWallet, userAddress, userIdentity;
let locPassDaysLeft = null;

// BackUps state ‚Äì last scan
let backupsHasScan = false;
let backupsLastPolicyId = '';
let backupsLastRows = [];     // [{ unit, policyId, assetName, quantity, metadata }, ...]
let backupsLastKeys = [];     // sorted list of all metadata keys
  let backupsIsHolder = false;                 // true if wallet meets Refresh requirement
let backupsRequiresPayment = false;          // true for non-holders
let backupsPaidForCurrentPolicy = false;     // set to true after successful payment
let backupsCurrentFeeAda = 0;                // dynamic fee for current scan
let backupsCurrentFeeLovelace = '0';
let backupsCurrentAssetCount = 0;


// ---------------------------------------------------------
// Helper text for gate
// ---------------------------------------------------------
function buildRequirementsLine() {
  return ACCESS_POLICIES
    .map(p => `${p.minAssets} ${p.label}`)
    .join(' + ');
}

function buildRequirementsDetail(foundMap) {
  return ACCESS_POLICIES
    .map(p => {
      const found = foundMap[p.policyId] ?? 0;
      return `${p.label}: ${found} / ${p.minAssets}`;
    })
    .join('\n');
}

function getPrimaryPurchaseUrl() {
  return (ACCESS_POLICIES[0] && ACCESS_POLICIES[0].purchaseUrl) || 'https://www.jpg.store/';
}

// Set gate text
instructionsEl.textContent = `Connect a Cardano wallet to continue.`;
gateBlurbEl.textContent =
  `If your wallet holds at least ${buildRequirementsLine()}, you have free BackUps access. ` +
  `Otherwise, BackUps costs 100‚Ç≥ per 1000 assets (per policy BackUp) for non-holders.`;


// ---------------------------------------------------------
// Mesh wallet detection
// ---------------------------------------------------------
async function detect() {
  try {
    const wallets = await BrowserWallet.getInstalledWallets();

    if (!wallets.length) {
      sel.innerHTML = '<option>(no wallets detected)</option>';
      return;
    }

    // Prefer "mesh" if present
    wallets.sort((a, b) =>
      a.id === 'mesh' ? -1 : b.id === 'mesh' ? 1 : 0
    );

    sel.innerHTML = wallets
      .map((w) => `<option value="${w.id}">${w.name}</option>`)
      .join('');

    sel.value = wallets[0].id;
    btn.disabled = false;
  } catch (err) {
    console.error('Wallet detection failed:', err);
    sel.innerHTML = '<option>(wallet detection failed)</option>';
  }
}

// ---------------------------------------------------------
// Paid access tracking via loc_access.php (same pattern as LOC)
// ---------------------------------------------------------
async function checkPaidAccessStatus() {
  if (!userIdentity) return null;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'check',
        identity: userIdentity,
      }),
    });

    if (!res.ok) {
      console.error('[BackUps] checkPaidAccessStatus HTTP error:', res.status);
      return null;
    }

    const data = await res.json();
    console.log('[BackUps] checkPaidAccessStatus response:', data);

    if (data.status === 'active') {
      return data; // { status, lastPaidDate, expiresOn }
    }

    return null;
  } catch (err) {
    console.error('[BackUps] checkPaidAccessStatus error:', err);
    return null;
  }
}

async function logPaidAccess(txHash) {
  if (!userIdentity) return;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'log',
        identity: userIdentity,
        txHash,
      }),
    });

    const data = await res.json().catch(() => null);
    console.log('[BackUps] logPaidAccess response:', data);
  } catch (err) {
    console.error('[BackUps] logPaidAccess error:', err);
  }
}

// ---------------------------------------------------------
// Small helpers
// ---------------------------------------------------------
function shortenAddress(addr) {
  if (!addr || typeof addr !== 'string') return '‚Äì';
  if (addr.length <= 16) return addr;
  return addr.slice(0, 8) + '‚Ä¶' + addr.slice(-8);
}

function hexToAscii(hex) {
  if (!hex || typeof hex !== 'string') return '';
  let str = '';
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.slice(i, i + 2), 16);
    if (!Number.isNaN(code)) {
      str += String.fromCharCode(code);
    }
  }
  return str;
}

// ---------------------------------------------------------
// Blockfrost policy-wide scan helpers for BackUps
// ---------------------------------------------------------
async function fetchAllAssetsForPolicy(policyId) {
  if (!BLOCKFROST_PROJECT_ID) {
    throw new Error('Blockfrost project ID is not configured.');
  }
  let page = 1;
  let all = [];

  while (true) {
    const res = await fetch(
      `${BLOCKFROST_ENDPOINT}/assets/policy/${policyId}?page=${page}`,
      { headers: { project_id: BLOCKFROST_PROJECT_ID } }
    );

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`Blockfrost error ${res.status}: ${text}`);
    }

    const chunk = await res.json();
    if (!Array.isArray(chunk) || chunk.length === 0) break;

    all = all.concat(chunk);
    page++;
  }

  return all; // each entry has .asset (unit), .quantity, ...
}

async function fetchMetadataForAsset(unit) {
  const res = await fetch(
    `${BLOCKFROST_ENDPOINT}/assets/${unit}`,
    { headers: { project_id: BLOCKFROST_PROJECT_ID } }
  );

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.warn(`Blockfrost /assets/${unit} error ${res.status}: ${text}`);
    return {};
  }

  const data = await res.json();
  return data.onchain_metadata || {};
}

function renderBackupsResults() {
  const table    = document.getElementById('backupsResultsTable');
  const tbody    = table?.querySelector('tbody');
  const summary  = document.getElementById('backupsResultsSummary');
  const zipBtn   = document.getElementById('backupsDownloadZipBtn');

  if (!table || !tbody || !summary || !zipBtn) return;

  tbody.innerHTML = '';

  if (!backupsHasScan || !backupsLastRows.length) {
    table.classList.add('hidden');
    summary.innerHTML =
      '<span>No assets found for this policy on chain.</span>';
    zipBtn.disabled = true;
    return;
  }

  const count = backupsLastRows.length;
  summary.innerHTML =
    `<span>Found <strong>${count}</strong> asset(s) under policy <code>${backupsLastPolicyId}</code>.</span>`;

  // reset per-scan payment state
  backupsCurrentAssetCount = count;
  backupsCurrentFeeAda = computeBackupsFeeAda(count);
  backupsCurrentFeeLovelace = String(backupsCurrentFeeAda * 1_000_000);
  backupsPaidForCurrentPolicy = backupsIsHolder; // holders never pay

  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');

  if (feeStatus) feeStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }

  // sort by assetName asc
  backupsLastRows.sort((a, b) =>
    (a.assetName || '').localeCompare(b.assetName || '')
  );

  for (const row of backupsLastRows) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.assetName || '(no ASCII name)'}</td>
      <td>${row.quantity}</td>
      <td>${row.unit}</td>
    `;
    tbody.appendChild(tr);
  }

  table.classList.remove('hidden');

  if (backupsIsHolder) {
    if (feeStatus) {
      feeStatus.textContent =
        `You are a Refresh holder (‚â• ${ACCESS_POLICIES[0].minAssets}). No BackUps fee for this policy.`;
    }
    zipBtn.disabled = false;
  } else {
    if (backupsCurrentFeeAda <= 0) {
      if (feeStatus) {
        feeStatus.textContent =
          'No assets under this policy, so there is nothing to pay or download.';
      }
      zipBtn.disabled = true;
    } else {
      if (feeStatus) {
        feeStatus.textContent =
          `This policy has ${count} asset(s).\n` +
          `BackUps fee is ${backupsCurrentFeeAda}‚Ç≥ (100‚Ç≥ per 1000 assets).\n` +
          `Press ‚ÄúPay & unlock ZIP‚Äù to process the transaction.`;
      }
      if (payBtn) {
        payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
        payBtn.style.display = 'inline-flex';
      }
      zipBtn.disabled = true;
    }
  }
}


async function backupsScanForPolicy() {
  const statusEl  = document.getElementById('backupsScanStatus');
  const policyEl  = document.getElementById('backupsPolicyInput');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const table     = document.getElementById('backupsResultsTable');
  const tbody     = table?.querySelector('tbody');

  if (statusEl) statusEl.textContent = '';
  backupsHasScan       = false;
  backupsLastPolicyId  = '';
  backupsLastRows      = [];
  backupsLastKeys      = [];
  zipBtn.disabled      = true;
  if (tbody) tbody.innerHTML = '';
  table?.classList.add('hidden');

  const rawPolicy = (policyEl?.value || '').trim();
  if (!rawPolicy) {
    if (statusEl) statusEl.textContent = 'Enter a policy ID to scan.';
    return;
  }
  if (rawPolicy.length !== 56 && statusEl) {
    statusEl.textContent =
      'Policy ID length looks unusual (not 56 chars). Still scanning in case this is test data‚Ä¶';
  }

  if (!BLOCKFROST_PROJECT_ID) {
    if (statusEl) statusEl.textContent =
      'Blockfrost project ID is not set in the code. Please configure BLOCKFROST_PROJECT_ID.';
    return;
  }

  try {
    if (statusEl) statusEl.textContent = 'Scanning policy via Blockfrost‚Ä¶';

    const baseAssets = await fetchAllAssetsForPolicy(rawPolicy);
    if (!baseAssets.length) {
      backupsHasScan      = true;
      backupsLastPolicyId = rawPolicy;
      renderBackupsResults();
      if (statusEl) statusEl.textContent = 'Scan complete. No assets under this policy.';
      return;
    }

    const allKeys = new Set();
    const rows    = [];

    // fetch metadata for each asset (sequentially; can be optimized later if needed)
    for (let i = 0; i < baseAssets.length; i++) {
      const base = baseAssets[i];
      const unit = base.asset; // full hex unit (policy + name)
      const quantity = String(base.quantity ?? '0');

      const policyHex = unit.slice(0, 56);
      const nameHex   = unit.slice(56);
      const assetName = hexToAscii(nameHex) || '(no ASCII name)';

      if (statusEl) {
        statusEl.textContent =
          `Scanning ${i + 1} / ${baseAssets.length}‚Ä¶`;
      }

      const metadata = await fetchMetadataForAsset(unit);

      Object.keys(metadata).forEach(k => allKeys.add(k));

      rows.push({
        unit,
        policyId: policyHex,
        assetName,
        quantity,
        metadata,
      });
    }

    backupsHasScan      = true;
    backupsLastPolicyId = rawPolicy;
    backupsLastRows     = rows;
    backupsLastKeys     = Array.from(allKeys).sort();

    renderBackupsResults();

    if (statusEl) {
      statusEl.textContent = 'Scan complete.';
    }

  } catch (err) {
    console.error('[BackUps] scan error:', err);
    if (statusEl) {
      statusEl.textContent =
        'An error occurred while scanning. Check console for details.';
    }
  }
}

function csvEscape(value) {
  const str = value == null ? '' : String(value);
  if (/[",\n\r]/.test(str)) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

async function exportBackupsZip() {
  if (!backupsHasScan || !backupsLastRows.length || !window.JSZip || !window.saveAs) {
    return;
  }

  const zip    = new JSZip();
  const policy = backupsLastPolicyId || 'unknown_policy';
  const root   = zip.folder(`policy_${policy}`) || zip;

  // 1) assets.json ‚Äì CIP-25 style for all assets (no "unit" field)
  const allCip25 = { "721": {} };

  for (const row of backupsLastRows) {
    const meta     = row.metadata || {};
    const policyId = row.policyId;

    // Asset key inside the policy: same logic as per-asset files
    const assetKey = (meta.name && typeof meta.name === 'string')
      ? meta.name
      : (row.assetName || row.unit);

    if (!allCip25["721"][policyId]) {
      allCip25["721"][policyId] = {};
    }

    allCip25["721"][policyId][assetKey] = meta;
  }

  root.file('assets.json', JSON.stringify(allCip25, null, 2));


  // 2) metadata.csv ‚Äì spreadsheet with all metadata keys
  const keys    = backupsLastKeys;
  const headers = ['unit', 'assetName', 'quantity', ...keys];
  const lines   = [headers.map(csvEscape).join(',')];

  for (const row of backupsLastRows) {
    const meta = row.metadata || {};
    const vals = [
      row.unit,
      row.assetName,
      row.quantity,
      ...keys.map(k => {
        const v = meta[k];
        if (v === null || v === undefined) return '';
        if (typeof v === 'object') return JSON.stringify(v);
        return String(v);
      }),
    ];
    lines.push(vals.map(csvEscape).join(','));
  }

  const csvString = lines.join('\n');
  root.file('metadata.csv', csvString);

  // 3) by_asset/*.json ‚Äì one CIP-25 style JSON per asset
  const perAsset = root.folder('by_asset');
  for (const row of backupsLastRows) {
    const meta = row.metadata || {};

    // Asset key inside the policy: prefer metadata.name, then ASCII asset name, then unit
    const assetKey = (meta.name && typeof meta.name === 'string')
      ? meta.name
      : (row.assetName || row.unit);

    const cip25 = {
      "721": {
        [row.policyId]: {
          [assetKey]: meta
        }
      }
    };

    const safeName =
      row.assetName && /^[a-z0-9_\-]+$/i.test(row.assetName)
        ? row.assetName
        : row.unit;

    perAsset.file(
      `${safeName}.json`,
      JSON.stringify(cip25, null, 2)
    );
  }

  // 4) images/ ‚Äì download image files from IPFS / HTTP where possible
  const imgFolder = root.folder('images');
  const imageFetchPromises = [];

  for (const row of backupsLastRows) {
    const meta = row.metadata || {};
    let imgField = meta.image;

    if (!imgField) continue;

    // Some collections use an array of images ‚Äì grab the first string
    if (Array.isArray(imgField)) {
      imgField = imgField.find(v => typeof v === 'string') || null;
    }
    if (typeof imgField !== 'string') continue;

    let finalUrl = null;

    if (imgField.startsWith('ipfs://')) {
      // ipfs://Qm... or ipfs://ipfs/Qm...
      let path = imgField.replace(/^ipfs:\/\//, '');
      if (path.startsWith('ipfs/')) {
        path = path.slice(5);
      }
      // You can swap to your preferred gateway here
      finalUrl = `https://ipfs.io/ipfs/${path}`;
    } else if (imgField.startsWith('https://') || imgField.startsWith('http://')) {
      finalUrl = imgField;
    } else {
      // Unknown scheme (e.g. bare CID) ‚Äì skip for now
      continue;
    }

    if (!finalUrl) continue;

    const safeName =
      row.assetName && /^[a-z0-9_\-]+$/i.test(row.assetName)
        ? row.assetName
        : row.unit;

    imageFetchPromises.push(
      (async () => {
        try {
          const res = await fetch(finalUrl);
          if (!res.ok) {
            console.warn('[BackUps] Image fetch failed for', finalUrl, res.status);
            return;
          }
          const contentType = res.headers.get('content-type') || '';
          let ext = 'bin';

          if (contentType.includes('png')) ext = 'png';
          else if (contentType.includes('jpeg') || contentType.includes('jpg')) ext = 'jpg';
          else if (contentType.includes('gif')) ext = 'gif';
          else if (contentType.includes('webp')) ext = 'webp';
          else {
            // Try to guess from URL path
            try {
              const urlObj = new URL(finalUrl);
              const path   = urlObj.pathname.toLowerCase();
              if (path.endsWith('.png')) ext = 'png';
              else if (path.endsWith('.jpg') || path.endsWith('.jpeg')) ext = 'jpg';
              else if (path.endsWith('.gif')) ext = 'gif';
              else if (path.endsWith('.webp')) ext = 'webp';
            } catch (_) { /* ignore URL parse issues */ }
          }

          const ab = await res.arrayBuffer();
          imgFolder.file(`${safeName}.${ext}`, ab);
        } catch (err) {
          console.warn('[BackUps] Image fetch error for', finalUrl, err);
        }
      })()
    );
  }

  // Wait for all image downloads to finish (or fail) before finalizing ZIP
  if (imageFetchPromises.length) {
    await Promise.all(imageFetchPromises);
  }

  // 5) README.txt
  const readme = [
    'BackUps by The Refresh',
    '-----------------------',
    '',
    `Policy ID: ${policy}`,
    '',
    'Contents:',
    '- assets.json       : All assets under the policy, including metadata per asset.',
    '- metadata.csv      : Spreadsheet-friendly view of all on-chain metadata properties.',
    '- by_asset/*.json   : One CIP-25 721-style JSON file per asset.',
    '- images/*          : Image files fetched from IPFS / HTTPS image URLs where available.',
    '',
    'Generated for backup / analysis. No private keys were used or exposed.',
  ].join('\n');
  root.file('README.txt', readme);

  const blob     = await zip.generateAsync({ type: 'blob' });
  const filename = `BackUps_${policy}.zip`;
  saveAs(blob, filename);
}

  async function payForCurrentPolicy() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }
  if (!backupsRequiresPayment || backupsIsHolder) {
    // nothing to do, holders don't pay here
    return;
  }
  if (!backupsHasScan || !backupsLastRows.length || backupsCurrentFeeAda <= 0) {
    alert('Scan a policy with assets before paying.');
    return;
  }

  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');

  try {
    if (feeStatus) {
      feeStatus.textContent =
        `Building ${backupsCurrentFeeAda}‚Ç≥ BackUps transaction for policy ${backupsLastPolicyId}‚Ä¶`;
    }
    if (payBtn) {
      payBtn.disabled = true;
      payBtn.textContent = 'Waiting for wallet‚Ä¶';
    }

    const tx = new Transaction({ initiator: meshWallet });

    const lovelace = String(backupsCurrentFeeAda * 1_000_000);
    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, lovelace);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Policy payment tx hash:', txHash);

    backupsPaidForCurrentPolicy = true;

    if (feeStatus) {
      feeStatus.textContent =
        `Payment confirmed for policy ${backupsLastPolicyId}.\n` +
        `Tx: ${txHash}\nYou can now download the BackUps .zip for this policy.`;
    }
    if (zipBtn) {
      zipBtn.disabled = false;
    }

    // TODO (server-side, later):
    // log wallet + policyId + asset count + txHash
    // so future visits can re-use this payment if the policy hasn't changed.

  } catch (err) {
    console.error('[BackUps] payForCurrentPolicy error:', err);
    if (feeStatus) {
      feeStatus.textContent =
        'Payment failed or was rejected. No funds were taken. You can try again.';
    }
  } finally {
    if (payBtn) {
      payBtn.disabled = false;
      payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
    }
  }
}


// ---------------------------------------------------------
// Initialize BackUps app after gate
// (keeping initLocApp name so gate flow stays simple)
// ---------------------------------------------------------
let backupsInitialized = false;
async function initLocApp(accessVia) {
  if (backupsInitialized) return;
  backupsInitialized = true;

  const walletShortEl = document.getElementById('backupsWalletShort');
  const accessTypeEl  = document.getElementById('backupsAccessType');

  if (!meshWallet) return;
  if (!userAddress) {
    userAddress = await meshWallet.getChangeAddress();
  }

  if (walletShortEl) walletShortEl.textContent = shortenAddress(userAddress);

if (accessTypeEl) {
  if (accessVia === 'holder') {
    accessTypeEl.textContent = 'Free access via OG The Refresh holdings.';
  } else {
    accessTypeEl.textContent = 'Per-policy BackUps pricing (non-holder).';
  }
}
backupsIsHolder = (accessVia === 'holder');
backupsRequiresPayment = !backupsIsHolder;
  
// Wire BackUps buttons
const scanBtn = document.getElementById('backupsScanBtn');
const zipBtn  = document.getElementById('backupsDownloadZipBtn');
const payBtn  = document.getElementById('backupsPayBtn');

scanBtn?.addEventListener('click', backupsScanForPolicy);
zipBtn?.addEventListener('click', exportBackupsZip);
payBtn?.addEventListener('click', payForCurrentPolicy);

}

// ---------------------------------------------------------
// Gate: check policy assets & paid pass
// ---------------------------------------------------------
async function checkPolicyAssets() {
  if (!meshWallet) return;

  walletStatus.classList.remove('hidden');
  walletStatus.textContent = 'Checking Wallet‚Ä¶';
  accessMessage.textContent = '';
  accessMessage.classList.remove('error');

  try {
    const assets = await meshWallet.getAssets();
    console.log('[BackUps Gate] Assets:', assets);

    const required = Object.create(null);
    for (const p of ACCESS_POLICIES) required[p.policyId] = 0;

    for (const asset of assets) {
      if (asset && required[asset.policyId] !== undefined) {
        required[asset.policyId]++;
      }
    }

const unmet = ACCESS_POLICIES.filter(
  p => (required[p.policyId] || 0) < p.minAssets
);

if (unmet.length === 0) {
  backupsIsHolder = true;
  backupsRequiresPayment = false;

  const detail = buildRequirementsDetail(required);

  walletStatus.textContent =
    `‚úÖ Access granted.\n${detail}`;

  accessMessage.classList.remove('error');
  accessMessage.innerHTML = `<strong>Access granted. Loading BackUps‚Ä¶</strong>`;

  payAccessBtn.style.display = 'none';

  protectedArea.classList.remove('hidden');
  gateOverlay.classList.add('hidden');
  initLocApp('holder');
} else {
  backupsIsHolder = false;
  backupsRequiresPayment = true;

  const detail = buildRequirementsDetail(required);
  walletStatus.textContent = detail;

  accessMessage.classList.add('error');
  accessMessage.innerHTML =
    `You don‚Äôt yet meet the free BackUps holder requirements.<br>` +
    `Pricing for non-holders is <strong>100‚Ç≥ per 1000 assets</strong> (per policy BackUp).<br>` +
    `Press ‚ÄúEnter BackUps‚Äù below to continue and scan a policy.`;

  payAccessBtn.textContent = 'Enter BackUps';
  payAccessBtn.style.display = 'inline-flex';

  // clicking this just opens BackUps with per-policy pricing mode
  payAccessBtn.onclick = () => {
    protectedArea.classList.remove('hidden');
    gateOverlay.classList.add('hidden');
    initLocApp('nonholder');
  };
}

      accessMessage.classList.add('error');
      accessMessage.innerHTML =
        `You don‚Äôt yet meet the free BackUps holder requirements.<br>` +
        `<a href="${getPrimaryPurchaseUrl()}" target="_blank" rel="noopener noreferrer">
           Purchase Assets
         </a> or pay ${ACCESS_PASS_FEE_ADA}‚Ç≥ for 30 days access below.`;

      payAccessBtn.style.display = 'inline-flex';
    }

  } catch (err) {
    console.error(err);
    walletStatus.textContent = 'Error checking wallet assets.';
    accessMessage.classList.add('error');
    accessMessage.textContent = 'An error occurred while checking your wallet. Please try again.';
  }
}

// ---------------------------------------------------------
// Pay 5‚Ç≥ for 30 days BackUps access
// ---------------------------------------------------------
async function payForLocAccess() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }

  if (!GATE_RECIPIENT_ADDRESS) {
    alert('Gate recipient address is not configured yet.\n\nPlease set GATE_RECIPIENT_ADDRESS in the code.');
    return;
  }

  try {
    payAccessBtn.disabled = true;
    payAccessBtn.textContent = 'Preparing payment‚Ä¶';
    accessMessage.classList.remove('error');
    accessMessage.textContent = `Building ${ACCESS_PASS_FEE_ADA}‚Ç≥ BackUps access transaction‚Ä¶`;

    const tx = new Transaction({ initiator: meshWallet });

    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, ACCESS_PASS_FEE_LOVELACE);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Access payment tx hash:', txHash);

    await logPaidAccess(txHash);

    walletStatus.textContent = `BackUps access paid. Tx: ${txHash}`;
    accessMessage.classList.remove('error');
    accessMessage.innerHTML = `<strong>Access granted. Welcome to BackUps.</strong>`;

    locPassDaysLeft = 30;

    protectedArea.classList.remove('hidden');
    gateOverlay.classList.add('hidden');
    initLocApp('pass');

  } catch (err) {
    console.error('[BackUps] payForLocAccess error:', err);
    accessMessage.classList.add('error');
    accessMessage.textContent =
      'Payment failed or was rejected. No funds were taken. You can try again.';
  } finally {
    payAccessBtn.disabled = false;
    payAccessBtn.textContent = `Pay ${ACCESS_PASS_FEE_ADA}‚Ç≥ for 30 days access`;
  }
}

// ---------------------------------------------------------
// Connect wallet via Mesh
// ---------------------------------------------------------
async function connect() {
  const walletId = sel.value;
  if (!walletId) {
    alert('Select a wallet');
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Connecting‚Ä¶';

  try {
    meshWallet  = await BrowserWallet.enable(walletId);
    userAddress = await meshWallet.getChangeAddress();

    // Try reward (stake) address as identity, fallback to payment address
    try {
      const rewardAddrs = await meshWallet.getRewardAddresses?.();
      if (Array.isArray(rewardAddrs) && rewardAddrs.length > 0) {
        userIdentity = rewardAddrs[0];
      } else {
        userIdentity = userAddress;
      }
    } catch (e) {
      console.warn('[BackUps] getRewardAddresses not available, using payment address as identity.');
      userIdentity = userAddress;
    }

    btn.textContent = `Connected: ${walletId}`;
    sel.disabled = true;

    await checkPolicyAssets();

  } catch (e) {
    console.error('Wallet connection failed:', e);

    let humanMsg =
      'Connection failed.\n\n' +
      '‚Ä¢ If your wallet uses a PIN/password, open the wallet extension/app and unlock it first.\n' +
      '‚Ä¢ Then come back here and press "Connect Wallet" again.';

    if (e && e.message) {
      humanMsg = `Connection failed: ${e.message}\n\n` + humanMsg;
    }

    alert(humanMsg);
    btn.textContent = 'Connect Wallet';
    btn.disabled = false;
  }
}

document.addEventListener('DOMContentLoaded', detect);
btn.addEventListener('click', connect);
</script>

</body>
</html>

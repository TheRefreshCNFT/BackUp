<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BackUps by The Refresh</title>
  <style>
    :root {
      --gap: 1rem;
      --pad: .5rem;
      --primary: #2196F3;
      --primary-dark: #1976D2;
      --secondary: #21CBF3;
      --text: #e4e8ff;
      --text-light: #9aa3d9;
      --bg: #050810;
      --card-bg: rgba(7, 12, 30, 0.92);
      --border: rgba(120, 141, 255, 0.35);
      --success: #4CAF50;
      --error: #f44336;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #000;
      color: var(--text);
      line-height: 1.6;
    }

    /* --- WALLET GATE OVERLAY --- */
    #gateOverlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 10;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      background: radial-gradient(circle at top left, #202738 0, #050810 55%, #020308 100%);
      color: #e4e8ff;
    }

    header {
      position: relative;
      background: transparent;
      color: white;
      text-align: center;
      padding: 2rem var(--pad) 1.5rem;
      box-shadow: none;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    #description {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 1.5rem;
    }

    #instructions {
      font-size: 1rem;
      margin: 1rem 0;
      color: #a9b5ff;
    }

    #walletStatus {
      background: rgba(9, 16, 40, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(106, 255, 183, 0.4);
      color: #a7ffcb;
      padding: 0.5rem 1.5rem;
      display: inline-block;
      margin-top: 1rem;
      font-weight: 500;
      backdrop-filter: blur(5px);
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 0 var(--pad);
    }

    .card {
      background: rgba(5, 10, 24, 0.9);
      border-radius: 18px;
      border: 1px solid rgba(120, 141, 255, 0.25);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      color: #e4e8ff;
      backdrop-filter: blur(10px);
      padding: 2rem;
      margin: 2rem auto;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    button:disabled,
.loc-btn-primary:disabled,
.loc-btn-secondary:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

    

    #connectBtn {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #connectBtn:hover {
      background: linear-gradient(135deg, #ff4b80, #ffd46b);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.7);
    }

    #connectBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    #payAccessBtn {
      margin-top: 0.75rem;
      background: linear-gradient(135deg, #21cbf3, #7cffb3);
      color: #050814;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      border-radius: 999px;
    }

    #payAccessBtn:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
    }

    select, input {
      padding: 0.8rem;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 1rem;
      width: 100%;
      background: rgba(3, 7, 20, 0.9);
      border-color: rgba(96, 125, 255, 0.6);
      color: #e4e8ff;
    }

    .hidden { display: none !important; }

    .access-message {
      margin-top: 1rem;
      font-size: 1rem;
      color: #b7c3ff;
      white-space: pre-line;
    }

    .access-message strong { color: var(--success); }
    .access-message.error { color: #ff8b94; }

    .access-message a {
      color: #ffc857;
      text-decoration: underline;
    }

    header .container {
      max-width: 860px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .brand-logo {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      width: 52px;
      height: auto;
      padding: 0.25rem;
      background: rgba(5, 8, 16, 0.9);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
    }

    header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.04em;
    }

    /* Gated area layout */
    .loc-container {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      max-width: 720px;
      margin: 0 auto;
      padding: 1.5rem 1.75rem;
    }

    .loc-header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .loc-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
    }

    .loc-title-accent {
      opacity: 0.8;
      font-size: 0.95em;
    }

    .loc-subtitle {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .loc-status-block {
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(6px);
    }

    .loc-status {
      margin: 0;
      font-size: 0.95rem;
    }

    .loc-status-ok {
      font-weight: 500;
    }

    .loc-main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 1.25rem;
      width: 100%;
    }

    .loc-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .loc-card {
      background: rgba(5, 12, 28, 0.95);
      border-radius: 0.9rem;
      border: 1px solid rgba(120, 141, 255, 0.2);
      padding: 1rem 1.1rem;
      font-size: 0.9rem;
    }

    .loc-card h3 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1rem;
    }

    .loc-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 0.75rem;
      font-size: 0.85rem;
    }

    .loc-field span {
      opacity: 0.85;
    }

    .loc-field input {
      border-radius: 0.6rem;
      padding: 0.55rem 0.7rem;
    }

    .loc-btn-primary,
    .loc-btn-secondary {
      border-radius: 999px;
      padding: 0.55rem 1rem;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    .loc-btn-primary {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 20px rgba(0,0,0,0.7);
      margin-top: 0.25rem;
    }

    .loc-btn-primary:hover {
      transform: translateY(-1px) scale(1.01);
    }

    .loc-btn-secondary {
      background: rgba(10, 18, 46, 0.9);
      color: #e4e8ff;
      border: 1px solid rgba(120, 141, 255, 0.6);
    }

    .loc-hint {
      font-size: 0.75rem;
      opacity: 0.75;
    }

    .loc-tx-status {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .prev-search-item {
  padding: 0.35rem 0.5rem;
  border-radius: 0.4rem;
  background: rgba(10, 18, 46, 0.7);
  margin-bottom: 0.25rem;
  cursor: pointer;
}

.prev-search-item:hover {
  background: rgba(20, 30, 70, 0.9);
}

.prev-search-policy {
  font-family: monospace;
  font-size: 0.75rem;
  word-break: break-all;
}

.prev-search-meta {
  font-size: 0.75rem;
  opacity: 0.8;
}

.prev-search-older-toggle {
  font-size: 0.75rem;
  margin-top: 0.25rem;
  cursor: pointer;
  text-decoration: underline;
}


    .table-wrapper {
      max-height: 260px;
      overflow: auto;
      margin-top: 0.5rem;
    }

    .loc-results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    

    .loc-results-table th,
    .loc-results-table td {
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 0.35rem 0.5rem;
      text-align: left;
      word-break: break-all;
    }

    .loc-results-table th {
      background: rgba(10, 18, 46, 0.9);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    #backupsResultsSummary code {
  font-size: 0.6em; /* roughly half the surrounding text size */
}


    @media (max-width: 800px) {
      .loc-main {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    @media (max-width: 600px) {
      header .container { padding-top: 1.5rem; }
      header h1 { font-size: 1.9rem; }
      .card { margin-top: 1.5rem; padding: 1.5rem; }
      .row { flex-direction: column; align-items: stretch; }
    }
  </style>
</head>
<body>

<!-- Gated area wrapper (shown only after access granted) -->
<div id="protectedArea" class="hidden">
  <div id="backupsContainer" class="loc-container">
    <header class="loc-header">
      <h2 class="loc-title">
        BackUps <span class="loc-title-accent">by The Refresh</span>
      </h2>
      <p class="loc-subtitle">
        One-click backup of all assets under a policy ID. No wallet scan, chain-wide view.
      </p>
    </header>

    <section class="loc-status-block">
      <p class="loc-status loc-status-ok">
        Connected wallet: <span id="backupsWalletShort">‚Äì</span><br/>
        Access type: <span id="backupsAccessType">‚Äì</span>
      </p>
    </section>

    <section class="loc-main">
      <!-- LEFT: controls -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Scan a policy</h3>

          <label class="loc-field">
            <span>Policy ID to backup</span>
            <input id="backupsPolicyInput"
                   type="text"
                   placeholder="Paste a 56-character policy ID (no spaces)"/>
          </label>

          <button type="button" id="backupsScanBtn" class="loc-btn-primary">
            Scan policy on chain
          </button>

          <p class="loc-hint">
            BackUps queries Blockfrost for all assets under this policy and grabs every
            on-chain metadata property it finds. No wallet contents are scanned for this step.
          </p>

          <p id="backupsScanStatus" class="loc-tx-status"></p>
          <div id="backupsPreviousSearches" class="loc-field">
  <span>Previous Searches</span>
  <div id="backupsPrevList" class="loc-hint">
    No previous searches yet.
  </div>
</div>

        </div>
      </div>

      <!-- RIGHT: results + ZIP export -->
      <div class="loc-column">
        <div class="loc-card">
          <h3>Results & export</h3>
          <div id="backupsResultsSummary" class="loc-field">
            <span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>
          </div>

<div class="table-wrapper">
  <table id="backupsResultsTable" class="loc-results-table hidden">
    <thead>
      <tr>
        <th>Asset Name (ASCII)</th>
        <th>Quantity</th>
        <th>Full Unit</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<p id="backupsFeeStatus" class="loc-tx-status"></p>
<p id="backupsQuoteWarning" class="loc-tx-status"></p>
          
<div style="display:flex; flex-wrap:wrap; gap:0.5rem; margin-top:0.75rem;">
  <button type="button"
          id="backupsPayBtn"
          class="loc-btn-secondary"
          style="display:none;">
    <!-- label is set in JS -->
    Pay &amp; unlock ZIP
  </button>

  <button type="button"
          id="backupsDownloadZipBtn"
          class="loc-btn-secondary"
          disabled>
    Download BackUps .zip
  </button>
</div>

        </div>
      </div>
    </section>
  </div>
</div>

<!-- WALLET GATE OVERLAY -->
<div id="gateOverlay">
  <img src="RF5.png" alt="Fre5h Logo" class="brand-logo">

  <header>
    <div class="container">
      <h1>BackUps Access</h1>

     <p id="description">BackUps is free for The Refresh Whales. Others pay a 10‚Ç≥ minimum, scaled at 10‚Ç≥ per 50 assets per policy BackUp.</p>

      <p id="instructions"></p>

      <div class="row" id="connectRow">
        <select id="walletSelect">
          <option value="">Select Wallet‚Ä¶</option>
        </select>
        <button id="connectBtn" disabled>Connect Wallet</button>
      </div>

      <div id="walletStatus" class="hidden"></div>
    </div>
  </header>

  <div class="container">
    <div class="card">
      <h2>Access Gate</h2>
<p class="access-message">
  The Refresh Whales get in VIP. Pricing for others is 10‚Ç≥ per 50 assets per policy BackUp (minimum 10‚Ç≥).
</p>


      <p id="gateBlurb"></p>
      <p id="accessMessage" class="access-message"></p>

      <!-- Shown only if policy requirements are NOT met -->
<button id="payAccessBtn" style="display:none;">
  Enter BackUps
</button>

    </div>
  </div>
</div>


<!-- JSZip + FileSaver for ZIP export (no integrity to avoid mismatch blocking) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"
        referrerpolicy="no-referrer"></script>


<script type="module">
import {
  BrowserWallet,
  Transaction,
} from 'https://esm.sh/@meshsdk/core@1.9.0-beta.62?bundle';

const sel           = document.getElementById('walletSelect');
const btn           = document.getElementById('connectBtn');
const walletStatus  = document.getElementById('walletStatus');
const accessMessage = document.getElementById('accessMessage');
const gateOverlay   = document.getElementById('gateOverlay');
const protectedArea = document.getElementById('protectedArea');

const instructionsEl = document.getElementById('instructions');
const gateBlurbEl    = document.getElementById('gateBlurb');
const payAccessBtn   = document.getElementById('payAccessBtn');

// TODO: replace with your real receive address (no extra text)
const GATE_RECIPIENT_ADDRESS =
  'addr1q9m2reerla2ccrkwz57rhwl7q8vj8y38x39nv4mq56ppjqmzs7jlke6nm3thlvvddtsnp52s62u0337y9h6d2gmma2wsmjx8nh';

// =========================================================
// Pricing / Fees
// 10‚Ç≥ per 50 assets (per policy BackUp), minimum 10‚Ç≥
// Examples:
//  1‚Äì50 assets  -> 10‚Ç≥
// 51‚Äì100 assets -> 20‚Ç≥
// 101‚Äì150       -> 30‚Ç≥
// =========================================================
const ASSETS_PER_BLOCK        = 50;
const ACCESS_FEE_PER_BLOCK_ADA = 10;

function computeBackupsFeeAda(assetCount) {
  if (!assetCount || assetCount <= 0) return 0;
  const blocks = Math.ceil(assetCount / ASSETS_PER_BLOCK);
  const fee    = blocks * ACCESS_FEE_PER_BLOCK_ADA;
  return Math.max(ACCESS_FEE_PER_BLOCK_ADA, fee); // still enforce 10‚Ç≥ minimum
}



// =========================================================
// Blockfrost config for BackUps (policy-based scan)
// =========================================================
const BLOCKFROST_ENDPOINT   = 'https://cardano-mainnet.blockfrost.io/api/v0';
// üîê IMPORTANT: put your mainnet Blockfrost project key here:
const BLOCKFROST_PROJECT_ID = 'mainnetehvvvJVoJUAz5DFJJz2L9fHZmkXlXTMP'; // e.g. 'mainnetXXXXX...'

// =========================================================
// Fre5h / The Refresh holder access requirements
// =========================================================
const ACCESS_POLICIES = [
  {
    policyId: 'adc5716393953403109c335e68c0384238fd19653e960e03afa1fb1f',
    minAssets: 25,
    label: 'OG The Refresh',
    purchaseUrl: 'https://www.jpg.store/collection/therefresh'
  }
];

// mesh / identity state
let meshWallet, userAddress, userIdentity;
let locPassDaysLeft = null;

// BackUps state ‚Äì last scan
let backupsHasScan = false;
let backupsLastPolicyId = '';
let backupsLastRows = [];     // [{ unit, policyId, assetName, quantity, metadata }, ...]
let backupsLastKeys = [];     // sorted list of all metadata keys
let backupsBaseAssets = null; // raw /assets/policy list (no metadata yet)
let backupsPreviousSearches = []; // [{ policyId, assetCount, feeAda, quotedAt }]

let backupsIsHolder = false;                 // true if wallet meets Refresh requirement
let backupsRequiresPayment = false;          // true for non-holders
let backupsPaidForCurrentPolicy = false;     // set to true after successful payment
let backupsCurrentFeeAda = 0;                // dynamic fee for current scan
let backupsCurrentFeeLovelace = '0';
let backupsCurrentAssetCount = 0;


// ---------------------------------------------------------
// Helper text for gate
// ---------------------------------------------------------
function buildRequirementsLine() {
  return ACCESS_POLICIES
    .map(p => `${p.minAssets} ${p.label}`)
    .join(' + ');
}

function buildRequirementsDetail(foundMap) {
  return ACCESS_POLICIES
    .map(p => {
      const found = foundMap[p.policyId] ?? 0;
      return `${p.label}: ${found} / ${p.minAssets}`;
    })
    .join('\n');
}

function getPrimaryPurchaseUrl() {
  return (ACCESS_POLICIES[0] && ACCESS_POLICIES[0].purchaseUrl) || 'https://www.jpg.store/';
}

// Set gate text
instructionsEl.textContent = `Connect a Cardano wallet to continue.`;
gateBlurbEl.textContent =
  `If your wallet holds at least ${buildRequirementsLine()}, you have VIP BackUps access with no additional fee.`;

// ---------------------------------------------------------
// Mesh wallet detection
// ---------------------------------------------------------
async function detect() {
  try {
    const wallets = await BrowserWallet.getInstalledWallets();

    if (!wallets.length) {
      sel.innerHTML = '<option>(no wallets detected)</option>';
      return;
    }

    // Prefer "mesh" if present
    wallets.sort((a, b) =>
      a.id === 'mesh' ? -1 : b.id === 'mesh' ? 1 : 0
    );

    sel.innerHTML = wallets
      .map((w) => `<option value="${w.id}">${w.name}</option>`)
      .join('');

    sel.value = wallets[0].id;
    btn.disabled = false;
  } catch (err) {
    console.error('Wallet detection failed:', err);
    sel.innerHTML = '<option>(wallet detection failed)</option>';
  }
}

// ---------------------------------------------------------
// Paid access tracking via loc_access.php (same pattern as LOC)
// ---------------------------------------------------------
async function checkPaidAccessStatus() {
  if (!userIdentity) return null;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'check',
        identity: userIdentity,
      }),
    });

    if (!res.ok) {
      console.error('[BackUps] checkPaidAccessStatus HTTP error:', res.status);
      return null;
    }

    const data = await res.json();
    console.log('[BackUps] checkPaidAccessStatus response:', data);

    if (data.status === 'active') {
      return data; // { status, lastPaidDate, expiresOn }
    }

    return null;
  } catch (err) {
    console.error('[BackUps] checkPaidAccessStatus error:', err);
    return null;
  }
}

async function logPaidAccess(txHash) {
  if (!userIdentity) return;

  try {
    const res = await fetch('loc_access.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'log',
        identity: userIdentity,
        txHash,
      }),
    });

    const data = await res.json().catch(() => null);
    console.log('[BackUps] logPaidAccess response:', data);
  } catch (err) {
    console.error('[BackUps] logPaidAccess error:', err);
  }
}

// ---------------------------------------------------------
// Small helpers
// ---------------------------------------------------------
function shortenAddress(addr) {
  if (!addr || typeof addr !== 'string') return '‚Äì';
  if (addr.length <= 16) return addr;
  return addr.slice(0, 8) + '‚Ä¶' + addr.slice(-8);
}

function hexToAscii(hex) {
  if (!hex || typeof hex !== 'string') return '';
  let str = '';
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.slice(i, i + 2), 16);
    if (!Number.isNaN(code)) {
      str += String.fromCharCode(code);
    }
  }
  return str;
}

async function loadPreviousSearches() {
  if (!userIdentity) return;

  try {
    const res = await fetch('backups_searches.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'list',
        identity: userIdentity,
      }),
    });

    if (!res.ok) return;

    const data = await res.json().catch(() => null);
    if (!data || !Array.isArray(data.searches)) return;

    backupsPreviousSearches = data.searches;
    renderPreviousSearches();
  } catch (err) {
    console.warn('[BackUps] loadPreviousSearches error:', err);
  }
}

async function savePreviousSearch(policyId, assetCount, feeAda) {
  if (!userIdentity || !policyId) return;

  const existingIndex = backupsPreviousSearches.findIndex(
    (s) => s.policyId === policyId
  );
  const now = Date.now();

  const record = { policyId, assetCount, feeAda, quotedAt: now };

  if (existingIndex >= 0) {
    backupsPreviousSearches[existingIndex] = record;
  } else {
    backupsPreviousSearches.push(record);
  }

  // keep newest first locally
  backupsPreviousSearches.sort(
    (a, b) => (b.quotedAt || 0) - (a.quotedAt || 0)
  );
  renderPreviousSearches();

  try {
    await fetch('backups_searches.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'save',
        identity: userIdentity,
        search: record,
      }),
    });
  } catch (err) {
    console.warn('[BackUps] savePreviousSearch error:', err);
  }
}

function renderPreviousSearches() {
  const wrapper = document.getElementById('backupsPrevList');
  if (!wrapper) return;

  if (!backupsPreviousSearches.length) {
    wrapper.textContent = 'No previous searches yet.';
    return;
  }

  wrapper.innerHTML = '';

  const maxAlwaysVisible = 3;
  const visibles = backupsPreviousSearches.slice(0, maxAlwaysVisible);
  const older   = backupsPreviousSearches.slice(maxAlwaysVisible);

  const makeItem = (s) => {
    const div = document.createElement('div');
    div.className = 'prev-search-item';
    div.innerHTML = `
      <div class="prev-search-policy">${s.policyId}</div>
      <div class="prev-search-meta">
        ${s.assetCount} asset(s) ‚Ä¢ quoted fee ${s.feeAda}‚Ç≥
      </div>
    `;
    div.addEventListener('click', () => {
      const input = document.getElementById('backupsPolicyInput');
      if (input) input.value = s.policyId;
      runQuotedScanFlow(s);
    });
    return div;
  };

  visibles.forEach((s) => wrapper.appendChild(makeItem(s)));

  if (older.length) {
    const olderToggle = document.createElement('div');
    olderToggle.className = 'prev-search-older-toggle';
    olderToggle.textContent = 'Show older searches';
    let expanded = false;

    olderToggle.addEventListener('click', () => {
      expanded = !expanded;
      olderToggle.textContent = expanded
        ? 'Hide older searches'
        : 'Show older searches';

      if (expanded) {
        older.forEach((s) => wrapper.appendChild(makeItem(s)));
      } else {
        // re-render to collapse
        renderPreviousSearches();
      }
    });

    wrapper.appendChild(olderToggle);
  }
}

function runQuotedScanFlow(search) {
  const statusEl  = document.getElementById('backupsScanStatus');
  const summary   = document.getElementById('backupsResultsSummary');
  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const quoteWarn = document.getElementById('backupsQuoteWarning');

  backupsHasScan              = false;
  backupsLastPolicyId         = search.policyId;
  backupsLastRows             = [];
  backupsLastKeys             = [];
  backupsBaseAssets           = null;
  backupsCurrentAssetCount    = search.assetCount;
  backupsCurrentFeeAda        = search.feeAda;
  backupsCurrentFeeLovelace   = String(search.feeAda * 1_000_000);
  backupsPaidForCurrentPolicy = backupsIsHolder; // holders still free

  if (zipBtn) zipBtn.disabled = true;

  if (statusEl) {
    statusEl.textContent =
      'Using your previous BackUps quote for this policy. No new on-chain scan was performed.';
  }

  if (summary) {
    summary.innerHTML =
      `<span>Policy <code>${search.policyId}</code> has a quoted total of <strong>${search.assetCount}</strong> asset(s).</span>`;
  }

  if (feeStatus) {
    if (backupsIsHolder) {
      feeStatus.textContent =
        `You are a Refresh holder (‚â• ${ACCESS_POLICIES[0].minAssets}). No BackUps fee for this policy.`;
    } else if (search.feeAda > 0) {
      feeStatus.textContent =
        `Quoted BackUps fee for this policy is ${search.feeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).\n` +
        `Press ‚ÄúPay & unlock ZIP‚Äù to proceed.`;
    } else {
      feeStatus.textContent =
        'No assets under this policy in your previous quote.';
    }
  }

  if (quoteWarn) {
    quoteWarn.textContent =
      'You can scan one policy one time. This quote is based on the asset count shown above.\n' +
      'If you do not pay and download today and more assets are minted later, you will need to pay the quoted amount to begin the BackUps process, and will be asked to pay the difference if the asset count has changed, before the ZIP can be downloaded.';
  }

  if (payBtn) {
    if (!backupsIsHolder && search.feeAda > 0) {
      payBtn.textContent = `Pay ${search.feeAda}‚Ç≥ & unlock ZIP`;
      payBtn.style.display = 'inline-flex';
      payBtn.disabled = false;
    } else {
      payBtn.style.display = 'none';
    }
  }
}


// ---------------------------------------------------------
// Blockfrost policy-wide scan helpers for BackUps
// ---------------------------------------------------------
async function fetchAllAssetsForPolicy(policyId) {
  if (!BLOCKFROST_PROJECT_ID) {
    throw new Error('Blockfrost project ID is not configured.');
  }
  let page = 1;
  let all = [];

  while (true) {
    const res = await fetch(
      `${BLOCKFROST_ENDPOINT}/assets/policy/${policyId}?page=${page}`,
      { headers: { project_id: BLOCKFROST_PROJECT_ID } }
    );

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`Blockfrost error ${res.status}: ${text}`);
    }

    const chunk = await res.json();
    if (!Array.isArray(chunk) || chunk.length === 0) break;

    all = all.concat(chunk);
    page++;
  }

  return all; // each entry has .asset (unit), .quantity, ...
}

async function fetchMetadataForAsset(unit) {
  const res = await fetch(
    `${BLOCKFROST_ENDPOINT}/assets/${unit}`,
    { headers: { project_id: BLOCKFROST_PROJECT_ID } }
  );

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.warn(`Blockfrost /assets/${unit} error ${res.status}: ${text}`);
    return {};
  }

  const data = await res.json();
  return data.onchain_metadata || {};
}

async function scanMetadataForCurrentPolicy(statusEl) {
  if (!backupsLastPolicyId) return;

  const policyId = backupsLastPolicyId;

  let baseAssets = backupsBaseAssets;
  if (!Array.isArray(baseAssets) || baseAssets.length === 0) {
    baseAssets = await fetchAllAssetsForPolicy(policyId);
    backupsBaseAssets = baseAssets;
  }

  const allKeys = new Set();
  const rows    = [];
  const total   = baseAssets.length;

  for (let i = 0; i < total; i++) {
    const base = baseAssets[i];
    const unit = base.asset; // full hex unit (policy + name)
    const quantity = String(base.quantity ?? '0');

    const policyHex = unit.slice(0, 56);
    const nameHex   = unit.slice(56);
    const assetName = hexToAscii(nameHex) || '(no ASCII name)';

    if (statusEl) {
      statusEl.textContent = `Scanning ${i + 1} / ${total}‚Ä¶`;
    }

    const metadata = await fetchMetadataForAsset(unit);

    Object.keys(metadata).forEach(k => allKeys.add(k));

    rows.push({
      unit,
      policyId: policyHex,
      assetName,
      quantity,
      metadata,
    });
  }

  backupsHasScan  = true;
  backupsLastRows = rows;
  backupsLastKeys = Array.from(allKeys).sort();

  renderBackupsResults();
}


function renderBackupsResults() {
  const table    = document.getElementById('backupsResultsTable');
  const tbody    = table?.querySelector('tbody');
  const summary  = document.getElementById('backupsResultsSummary');
  const zipBtn   = document.getElementById('backupsDownloadZipBtn');

  if (!table || !tbody || !summary || !zipBtn) return;

  tbody.innerHTML = '';

  if (!backupsHasScan || !backupsLastRows.length) {
    table.classList.add('hidden');
    summary.innerHTML =
      '<span>No assets found for this policy on chain.</span>';
    zipBtn.disabled = true;
    return;
  }

  const count = backupsLastRows.length;
  summary.innerHTML =
    `<span>Found <strong>${count}</strong> asset(s) under policy <code>${backupsLastPolicyId}</code>.</span>`;

  // recompute fee + asset count based on actual rows
  backupsCurrentAssetCount   = count;
  backupsCurrentFeeAda       = computeBackupsFeeAda(count);
  backupsCurrentFeeLovelace  = String(backupsCurrentFeeAda * 1_000_000);
  // NOTE: do NOT touch backupsPaidForCurrentPolicy here ‚Äì it‚Äôs controlled by gate/payment flow


  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');

  if (feeStatus) feeStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }

  // sort by assetName asc
  backupsLastRows.sort((a, b) =>
    (a.assetName || '').localeCompare(b.assetName || '')
  );

  for (const row of backupsLastRows) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.assetName || '(no ASCII name)'}</td>
      <td>${row.quantity}</td>
      <td>${row.unit}</td>
    `;
    tbody.appendChild(tr);
  }

  table.classList.remove('hidden');

  if (backupsIsHolder) {
    if (feeStatus) {
      feeStatus.textContent =
        `You are a Refresh holder (‚â• ${ACCESS_POLICIES[0].minAssets}). No BackUps fee for this policy.`;
    }
    zipBtn.disabled = false;
  } else {
    if (backupsCurrentFeeAda <= 0) {
      if (feeStatus) {
        feeStatus.textContent =
          'No assets under this policy, so there is nothing to pay or download.';
      }
      zipBtn.disabled = true;
    } else if (backupsPaidForCurrentPolicy) {
      // Non-holder, but this policy has already been paid for in this session
      if (feeStatus) {
        feeStatus.textContent =
          `Payment confirmed for this policy.\nYou can now download the BackUps .zip.`;
      }
      if (payBtn) {
        payBtn.style.display = 'none';
      }
      zipBtn.disabled = false;
    } else {
      // Non-holder, not yet paid
      if (feeStatus) {
feeStatus.textContent =
  `This policy has ${count} asset(s).\n` +
  `BackUps fee is ${backupsCurrentFeeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).\n` +
  `Press ‚ÄúPay & unlock ZIP‚Äù to process the transaction.`;

      }
      if (payBtn) {
        payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
        payBtn.style.display = 'inline-flex';
      }
      zipBtn.disabled = true;
    }
  }
}


async function backupsScanForPolicy() {
  const statusEl  = document.getElementById('backupsScanStatus');
  const policyEl  = document.getElementById('backupsPolicyInput');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const table     = document.getElementById('backupsResultsTable');
  const tbody     = table?.querySelector('tbody');
  const summary   = document.getElementById('backupsResultsSummary');
  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const quoteWarn = document.getElementById('backupsQuoteWarning');


  // reset state for new scan
  if (feeStatus) feeStatus.textContent = '';
  if (quoteWarn) quoteWarn.textContent = '';
  if (statusEl) statusEl.textContent = '';
  backupsHasScan              = false;
  backupsLastPolicyId         = '';
  backupsLastRows             = [];
  backupsLastKeys             = [];
  backupsBaseAssets           = null;
  backupsPaidForCurrentPolicy = backupsIsHolder; // holders effectively "prepaid" (free)
  backupsCurrentAssetCount    = 0;
  backupsCurrentFeeAda        = 0;
  backupsCurrentFeeLovelace   = '0';

  if (zipBtn) zipBtn.disabled = true;
  if (tbody) tbody.innerHTML = '';
  table?.classList.add('hidden');
  if (summary) {
    summary.innerHTML =
      '<span>No scan yet. Paste a policy ID and press ‚ÄúScan policy on chain‚Äù.</span>';
  }
  if (feeStatus) feeStatus.textContent = '';
  if (payBtn) {
    payBtn.style.display = 'none';
    payBtn.disabled = false;
  }

  const rawPolicy = (policyEl?.value || '').trim();
  if (!rawPolicy) {
    if (statusEl) statusEl.textContent = 'Enter a policy ID to scan.';
    return;
  }
  if (rawPolicy.length !== 56 && statusEl) {
    statusEl.textContent =
      'Policy ID length looks unusual (not 56 chars). Still scanning in case this is test data‚Ä¶';
  }

  if (!BLOCKFROST_PROJECT_ID) {
    if (statusEl) statusEl.textContent =
      'Blockfrost project ID is not set in the code. Please configure BLOCKFROST_PROJECT_ID.';
    return;
  }

  try {
    if (statusEl) statusEl.textContent = 'Fetching assets for policy via Blockfrost‚Ä¶';

    const baseAssets = await fetchAllAssetsForPolicy(rawPolicy);
    backupsBaseAssets         = baseAssets;
    backupsLastPolicyId       = rawPolicy;
    backupsCurrentAssetCount  = baseAssets.length;
    backupsCurrentFeeAda      = computeBackupsFeeAda(backupsCurrentAssetCount);
    backupsCurrentFeeLovelace = String(backupsCurrentFeeAda * 1_000_000);
        // Remember this quote server-side to avoid repeated full scans for this policy
    savePreviousSearch(rawPolicy, backupsCurrentAssetCount, backupsCurrentFeeAda);


    if (!baseAssets.length) {
      if (summary) {
        summary.innerHTML =
          `<span>No assets under policy <code>${rawPolicy}</code> were found on chain.</span>`;
      }
      if (statusEl) statusEl.textContent = 'Scan complete. No assets under this policy.';
      return;
    }

    if (backupsIsHolder) {
      // Holders: do full metadata scan immediately and unlock ZIP
      await scanMetadataForCurrentPolicy(statusEl);
      if (statusEl) statusEl.textContent = 'Scan complete.';
    } else {
      // Non-holders: show count + fee, but DO NOT fetch per-asset metadata yet
      if (summary) {
        summary.innerHTML =
          `<span>Policy <code>${rawPolicy}</code> has <strong>${backupsCurrentAssetCount}</strong> asset(s).</span>`;
      }

      if (backupsCurrentFeeAda <= 0) {
        if (feeStatus) {
          feeStatus.textContent =
            'No assets under this policy, so there is nothing to pay or download.';
        }
        if (zipBtn) zipBtn.disabled = true;
      } else {
        if (feeStatus) {
feeStatus.textContent =
  `This policy has ${backupsCurrentAssetCount} asset(s).\n` +
  `BackUps fee is ${backupsCurrentFeeAda}‚Ç≥ (10‚Ç≥ per 50 assets, minimum 10‚Ç≥).\n` +
  `Press ‚ÄúPay & unlock ZIP‚Äù to process the transaction.`;

        }
        if (payBtn) {
          payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
          payBtn.style.display = 'inline-flex';
          payBtn.disabled = false;
        }
        if (zipBtn) zipBtn.disabled = true;

        if (quoteWarn) {
          quoteWarn.textContent =
            'You can scan one policy one time. This quote is based on the asset count shown above.\n' +
            'If you do not pay and download today and more assets are minted later, you will need to pay the quoted amount again to begin a new BackUps run, and you may be asked to pay the difference to cover the higher count.\n' +
            'After payment, if the on-chain asset count has changed by the time metadata is fetched for download, an additional payment may be required before the ZIP can be prepared.';
        }

      }

      if (statusEl) {
        statusEl.textContent =
          'Asset list fetched. Complete payment to fetch metadata and enable ZIP download.';
      }
    }

  } catch (err) {
    console.error('[BackUps] scan error:', err);
    if (statusEl) {
      statusEl.textContent =
        'An error occurred while scanning. Check console for details.';
    }
  }
}


function csvEscape(value) {
  const str = value == null ? '' : String(value);
  if (/[",\n\r]/.test(str)) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

async function exportBackupsZip() {
  if (!backupsHasScan || !backupsLastRows.length || !window.JSZip || !window.saveAs) {
    return;
  }
  if (backupsRequiresPayment && !backupsIsHolder && !backupsPaidForCurrentPolicy) {
    alert('Complete payment for this policy before downloading the BackUps .zip.');
    return;
  }


  const zip    = new JSZip();
  const policy = backupsLastPolicyId || 'unknown_policy';
  const root   = zip.folder(`policy_${policy}`) || zip;

  // 1) assets.json ‚Äì CIP-25 style for all assets (no "unit" field)
  const allCip25 = { "721": {} };

  for (const row of backupsLastRows) {
    const meta     = row.metadata || {};
    const policyId = row.policyId;

    // Asset key inside the policy: same logic as per-asset files
    const assetKey = (meta.name && typeof meta.name === 'string')
      ? meta.name
      : (row.assetName || row.unit);

    if (!allCip25["721"][policyId]) {
      allCip25["721"][policyId] = {};
    }

    allCip25["721"][policyId][assetKey] = meta;
  }

  root.file('assets.json', JSON.stringify(allCip25, null, 2));


  // 2) metadata.csv ‚Äì spreadsheet with all metadata keys
  const keys    = backupsLastKeys;
  const headers = ['unit', 'assetName', 'quantity', ...keys];
  const lines   = [headers.map(csvEscape).join(',')];

  for (const row of backupsLastRows) {
    const meta = row.metadata || {};
    const vals = [
      row.unit,
      row.assetName,
      row.quantity,
      ...keys.map(k => {
        const v = meta[k];
        if (v === null || v === undefined) return '';
        if (typeof v === 'object') return JSON.stringify(v);
        return String(v);
      }),
    ];
    lines.push(vals.map(csvEscape).join(','));
  }

  const csvString = lines.join('\n');
  root.file('metadata.csv', csvString);

  // 3) by_asset/*.json ‚Äì one CIP-25 style JSON per asset
  const perAsset = root.folder('by_asset');
  for (const row of backupsLastRows) {
    const meta = row.metadata || {};

    // Asset key inside the policy: prefer metadata.name, then ASCII asset name, then unit
    const assetKey = (meta.name && typeof meta.name === 'string')
      ? meta.name
      : (row.assetName || row.unit);

    const cip25 = {
      "721": {
        [row.policyId]: {
          [assetKey]: meta
        }
      }
    };

    const safeName =
      row.assetName && /^[a-z0-9_\-]+$/i.test(row.assetName)
        ? row.assetName
        : row.unit;

    perAsset.file(
      `${safeName}.json`,
      JSON.stringify(cip25, null, 2)
    );
  }

  // 4) images/ ‚Äì download image files from IPFS / HTTP where possible
  const imgFolder = root.folder('images');
  const imageFetchPromises = [];

  for (const row of backupsLastRows) {
    const meta = row.metadata || {};
    let imgField = meta.image;

    if (!imgField) continue;

    // Some collections use an array of images ‚Äì grab the first string
    if (Array.isArray(imgField)) {
      imgField = imgField.find(v => typeof v === 'string') || null;
    }
    if (typeof imgField !== 'string') continue;

    let finalUrl = null;

    if (imgField.startsWith('ipfs://')) {
      // ipfs://Qm... or ipfs://ipfs/Qm...
      let path = imgField.replace(/^ipfs:\/\//, '');
      if (path.startsWith('ipfs/')) {
        path = path.slice(5);
      }
      // You can swap to your preferred gateway here
      finalUrl = `https://ipfs.io/ipfs/${path}`;
    } else if (imgField.startsWith('https://') || imgField.startsWith('http://')) {
      finalUrl = imgField;
    } else {
      // Unknown scheme (e.g. bare CID) ‚Äì skip for now
      continue;
    }

    if (!finalUrl) continue;

    const safeName =
      row.assetName && /^[a-z0-9_\-]+$/i.test(row.assetName)
        ? row.assetName
        : row.unit;

    imageFetchPromises.push(
      (async () => {
        try {
          const res = await fetch(finalUrl);
          if (!res.ok) {
            console.warn('[BackUps] Image fetch failed for', finalUrl, res.status);
            return;
          }
          const contentType = res.headers.get('content-type') || '';
          let ext = 'bin';

          if (contentType.includes('png')) ext = 'png';
          else if (contentType.includes('jpeg') || contentType.includes('jpg')) ext = 'jpg';
          else if (contentType.includes('gif')) ext = 'gif';
          else if (contentType.includes('webp')) ext = 'webp';
          else {
            // Try to guess from URL path
            try {
              const urlObj = new URL(finalUrl);
              const path   = urlObj.pathname.toLowerCase();
              if (path.endsWith('.png')) ext = 'png';
              else if (path.endsWith('.jpg') || path.endsWith('.jpeg')) ext = 'jpg';
              else if (path.endsWith('.gif')) ext = 'gif';
              else if (path.endsWith('.webp')) ext = 'webp';
            } catch (_) { /* ignore URL parse issues */ }
          }

          const ab = await res.arrayBuffer();
          imgFolder.file(`${safeName}.${ext}`, ab);
        } catch (err) {
          console.warn('[BackUps] Image fetch error for', finalUrl, err);
        }
      })()
    );
  }

  // Wait for all image downloads to finish (or fail) before finalizing ZIP
  if (imageFetchPromises.length) {
    await Promise.all(imageFetchPromises);
  }

  // 5) README.txt
  const readme = [
    'BackUps by The Refresh',
    '-----------------------',
    '',
    `Policy ID: ${policy}`,
    '',
    'Contents:',
    '- assets.json       : All assets under the policy, including metadata per asset.',
    '- metadata.csv      : Spreadsheet-friendly view of all on-chain metadata properties.',
    '- by_asset/*.json   : One CIP-25 721-style JSON file per asset.',
    '- images/*          : Image files fetched from IPFS / HTTPS image URLs where available.',
    '',
    'Generated for backup / analysis. No private keys were used or exposed.',
  ].join('\n');
  root.file('README.txt', readme);

  const blob     = await zip.generateAsync({ type: 'blob' });
  const filename = `BackUps_${policy}.zip`;
  saveAs(blob, filename);
}

async function payForCurrentPolicy() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }
  if (!backupsRequiresPayment || backupsIsHolder) {
    // Nothing to do here; holders don‚Äôt pay in this flow
    return;
  }
  if (!backupsLastPolicyId || !backupsBaseAssets || backupsCurrentFeeAda <= 0) {
    alert('Scan a policy with assets before paying.');
    return;
  }

  const feeStatus = document.getElementById('backupsFeeStatus');
  const payBtn    = document.getElementById('backupsPayBtn');
  const zipBtn    = document.getElementById('backupsDownloadZipBtn');
  const scanStatus = document.getElementById('backupsScanStatus');

  try {
    if (feeStatus) {
      feeStatus.textContent =
        `Building ${backupsCurrentFeeAda}‚Ç≥ BackUps transaction for policy ${backupsLastPolicyId}‚Ä¶`;
    }
    if (payBtn) {
      payBtn.disabled = true;
      payBtn.textContent = 'Waiting for wallet‚Ä¶';
    }
    if (zipBtn) zipBtn.disabled = true;

    const tx = new Transaction({ initiator: meshWallet });

    const lovelace = String(backupsCurrentFeeAda * 1_000_000);
    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, lovelace);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Policy payment tx hash:', txHash);

    backupsPaidForCurrentPolicy = true;

    if (feeStatus) {
      feeStatus.textContent =
        `Payment submitted for policy ${backupsLastPolicyId}.\n` +
        `Tx: ${txHash}\nFetching asset metadata and preparing ZIP‚Ä¶`;
    }

    // Now do the heavy per-asset metadata scan
    if (scanStatus) {
      scanStatus.textContent = 'Scanning assets and fetching on-chain metadata‚Ä¶';
    }
    await scanMetadataForCurrentPolicy(scanStatus || feeStatus || null);
    if (scanStatus) {
      scanStatus.textContent = 'Scan complete.';
    }

    // renderBackupsResults() was called inside scanMetadataForCurrentPolicy,
    // so at this point ZIP is unlocked for this policy.

  } catch (err) {
    console.error('[BackUps] payForCurrentPolicy error:', err);
    if (feeStatus) {
      feeStatus.textContent =
        'Payment failed or was rejected. No funds were taken. You can try again.';
    }
  } finally {
    if (payBtn) {
      payBtn.disabled = false;
      payBtn.textContent = `Pay ${backupsCurrentFeeAda}‚Ç≥ & unlock ZIP`;
    }
  }
}


// ---------------------------------------------------------
// Initialize BackUps app after gate
// (keeping initLocApp name so gate flow stays simple)
// ---------------------------------------------------------
let backupsInitialized = false;
async function initLocApp(accessVia) {
  if (backupsInitialized) return;
  backupsInitialized = true;

  const walletShortEl = document.getElementById('backupsWalletShort');
  const accessTypeEl  = document.getElementById('backupsAccessType');

  if (!meshWallet) return;
  if (!userAddress) {
    userAddress = await meshWallet.getChangeAddress();
  }

  if (walletShortEl) walletShortEl.textContent = shortenAddress(userAddress);

if (accessTypeEl) {
  if (accessVia === 'holder') {
    accessTypeEl.textContent = 'Free access via OG The Refresh holdings.';
  } else {
    accessTypeEl.textContent = 'Per-policy BackUps pricing (non-holder).';
  }
}
backupsIsHolder = (accessVia === 'holder');
backupsRequiresPayment = !backupsIsHolder;
  
// Wire BackUps buttons
const scanBtn = document.getElementById('backupsScanBtn');
const zipBtn  = document.getElementById('backupsDownloadZipBtn');
const payBtn  = document.getElementById('backupsPayBtn');

scanBtn?.addEventListener('click', backupsScanForPolicy);
zipBtn?.addEventListener('click', exportBackupsZip);
payBtn?.addEventListener('click', payForCurrentPolicy);

    // Render any previously loaded searches into the UI
  renderPreviousSearches();
}

async function checkPolicyAssets() {
  if (!meshWallet) return;

  walletStatus.classList.remove('hidden');
  walletStatus.textContent = 'Checking Wallet‚Ä¶';
  accessMessage.textContent = '';
  accessMessage.classList.remove('error');

  try {
    const assets = await meshWallet.getAssets();
    console.log('[BackUps Gate] Assets:', assets);

    const required = Object.create(null);
    for (const p of ACCESS_POLICIES) required[p.policyId] = 0;

    for (const asset of assets) {
      if (asset && required[asset.policyId] !== undefined) {
        required[asset.policyId]++;
      }
    }

    const unmet = ACCESS_POLICIES.filter(
      p => (required[p.policyId] || 0) < p.minAssets
    );

    if (unmet.length === 0) {
      // Holder: free access
      backupsIsHolder = true;
      backupsRequiresPayment = false;

      const detail = buildRequirementsDetail(required);

      walletStatus.textContent =
        `‚úÖ Access granted.\n${detail}`;

      accessMessage.classList.remove('error');
      accessMessage.innerHTML = `<strong>Access granted. Loading BackUps‚Ä¶</strong>`;

      payAccessBtn.style.display = 'none';

      protectedArea.classList.remove('hidden');
      gateOverlay.classList.add('hidden');
      initLocApp('holder');
    } else {
      // Non-holder: per-policy pricing mode
      backupsIsHolder = false;
      backupsRequiresPayment = true;

      const detail = buildRequirementsDetail(required);
      walletStatus.textContent = detail;

      accessMessage.classList.add('error');
      accessMessage.innerHTML =
        `You don‚Äôt yet meet the VIP BackUps access requirements.<br>` +
        `Press ‚ÄúEnter BackUps‚Äù below to continue and scan a policy with per-policy pricing.`;


      payAccessBtn.textContent = 'Enter BackUps';
      payAccessBtn.style.display = 'inline-flex';

      // Clicking this just opens BackUps in non-holder mode
      payAccessBtn.onclick = () => {
        protectedArea.classList.remove('hidden');
        gateOverlay.classList.add('hidden');
        initLocApp('nonholder');
      };
    }

  } catch (err) {
    console.error(err);
    walletStatus.textContent = 'Error checking wallet assets.';
    accessMessage.classList.add('error');
    accessMessage.textContent = 'An error occurred while checking your wallet. Please try again.';
  }
}

// ---------------------------------------------------------
// Pay 5‚Ç≥ for 30 days BackUps access
// ---------------------------------------------------------
async function payForLocAccess() {
  if (!meshWallet) {
    alert('Connect a wallet first.');
    return;
  }

  if (!GATE_RECIPIENT_ADDRESS) {
    alert('Gate recipient address is not configured yet.\n\nPlease set GATE_RECIPIENT_ADDRESS in the code.');
    return;
  }

  try {
    payAccessBtn.disabled = true;
    payAccessBtn.textContent = 'Preparing payment‚Ä¶';
    accessMessage.classList.remove('error');
    accessMessage.textContent = `Building ${ACCESS_PASS_FEE_ADA}‚Ç≥ BackUps access transaction‚Ä¶`;

    const tx = new Transaction({ initiator: meshWallet });

    tx.sendLovelace(GATE_RECIPIENT_ADDRESS, ACCESS_PASS_FEE_LOVELACE);

    if (!userAddress) {
      userAddress = await meshWallet.getChangeAddress();
    }
    tx.setChangeAddress(userAddress);

    const unsignedTx = await tx.build();
    const signedTx   = await meshWallet.signTx(unsignedTx);
    const txHash     = await meshWallet.submitTx(signedTx);

    console.log('[BackUps] Access payment tx hash:', txHash);

    await logPaidAccess(txHash);

    walletStatus.textContent = `BackUps access paid. Tx: ${txHash}`;
    accessMessage.classList.remove('error');
    accessMessage.innerHTML = `<strong>Access granted. Welcome to BackUps.</strong>`;

    locPassDaysLeft = 30;

    protectedArea.classList.remove('hidden');
    gateOverlay.classList.add('hidden');
    initLocApp('pass');

  } catch (err) {
    console.error('[BackUps] payForLocAccess error:', err);
    accessMessage.classList.add('error');
    accessMessage.textContent =
      'Payment failed or was rejected. No funds were taken. You can try again.';
  } finally {
    payAccessBtn.disabled = false;
    payAccessBtn.textContent = `Pay ${ACCESS_PASS_FEE_ADA}‚Ç≥ for 30 days access`;
  }
}

// ---------------------------------------------------------
// Connect wallet via Mesh
// ---------------------------------------------------------
async function connect() {
  const walletId = sel.value;
  if (!walletId) {
    alert('Select a wallet');
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Connecting‚Ä¶';

  try {
    meshWallet  = await BrowserWallet.enable(walletId);
    userAddress = await meshWallet.getChangeAddress();

    // Try reward (stake) address as identity, fallback to payment address
    try {
      const rewardAddrs = await meshWallet.getRewardAddresses?.();
      if (Array.isArray(rewardAddrs) && rewardAddrs.length > 0) {
        userIdentity = rewardAddrs[0];
      } else {
        userIdentity = userAddress;
      }
    } catch (e) {
      console.warn('[BackUps] getRewardAddresses not available, using payment address as identity.');
      userIdentity = userAddress;
    }

    // Load any previous searches for this identity (if any)
    await loadPreviousSearches();

    btn.textContent = `Connected: ${walletId}`;
    sel.disabled = true;

    await checkPolicyAssets();


  } catch (e) {
    console.error('Wallet connection failed:', e);

    let humanMsg =
      'Connection failed.\n\n' +
      '‚Ä¢ If your wallet uses a PIN/password, open the wallet extension/app and unlock it first.\n' +
      '‚Ä¢ Then come back here and press "Connect Wallet" again.';

    if (e && e.message) {
      humanMsg = `Connection failed: ${e.message}\n\n` + humanMsg;
    }

    alert(humanMsg);
    btn.textContent = 'Connect Wallet';
    btn.disabled = false;
  }
}

document.addEventListener('DOMContentLoaded', detect);
btn.addEventListener('click', connect);
</script>

</body>
</html>
